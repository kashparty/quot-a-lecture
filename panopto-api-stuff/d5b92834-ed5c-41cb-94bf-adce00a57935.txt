ID: d5b92834-ed5c-41cb-94bf-adce00a57935
Title: Haskell - higher-order functions-20211025_140257-Meeting Recording
Category: Haskell
Lecturer: Anthony Field
Date: 27/10/2021
OK, so welcome back. So we were looking at a higher order functions.
0:11
I ended up pumps well towards the back end of the last lecture, looking at the folding function or the family of folding functions.
0:17
So in principle, what they do is they collapse a list into a single value by inserting an invocation
0:25
of some function in this case in the and was some function F in between each element.
0:32
So this is particularly apparent if you think of the function as being an operator.
0:37
So it let you get x1 OpEx to OpEx and this is the right size diversion.
0:41
So in other words, the, the, the applications associate to the region,
0:47
there's a left associative equivalent which for left where they go the other way.
0:50
So either one is left or right. One is what's left. So maybe this is just a if you stop, if you find this confusing,
0:56
this is this I know is one of the more difficult things at this stage when you're a beginner.
1:04
So just to draw a little picture to show you how I think about foaled.
1:08
Right. And the same picture essentially applies bifold left as well.
1:12
So what's what's actually going on? Is this so I've got some list.
1:16
X one, x two, I'm going to put the coat value some values maybe in the middle of the is really matter without loss of generality any the values.
1:22
But I imagine I'm in the middle of the list. All right.
1:31
So I'm trying to collapse this list down into some some value.
1:35
Maybe it's a sum or a product or something or some other some other form of reduction
1:40
is sometimes called a reduction operation rather than a folding operation. Right.
1:43
So we know that the function application that we're dealing with is something in this struggle to show the full right version.
1:48
There's some function F which I'm folding into, which we sometimes folding.
1:55
We're inserting it into the list. There's some unit, some base case, which is what happens when the skin is empty.
1:59
And then there's this is and this is the X's that I'm playing with here.
2:06
So so I guess my X's. This looks like that. So the question is, what's the F or what's the what's the F?
2:10
So the way I think about the what's going on here is I imagined that I'm staring at this x k so I guess I've got the X came my hand,
2:18
because the thing about this function F here, down here, this function that it's only it's only actually looking at one element at the time
2:26
and under the insertion into the whole list is done by the folding function.
2:34
So this is left here only sees one element and also what else does it see?
2:38
It also sees in the case of Felger,
2:42
like something in which comes from collapsing or inserting or folding that function to all those elements to the right.
2:44
So I imagine in my mind's eye, I've got hold of my x k one of the axes and to the right is come.
2:51
The folding has happened. And what's come from the right is essentially and I think this is an accumulator.
2:57
Which comes in from that direction and this accumulator comes about because I've done the right f dot,
3:03
dot, dot on the remaining elements, but I don't worry about that.
3:09
So the question is, if I got an X and I've got an accumulator coming from the right, how do I take those two little fellas?
3:13
What what function f do I need to create a new. Accumulate later.
3:21
So imagine that I'm trying to sum the elements of the list, the act here is going to be the sum of the elements to my right.
3:26
This is the element I'm staring at. So it's completely clear that the function just should be the plus function.
3:33
And if it's a product, then the accumulated product and the objects just multiplied, in which case it becomes multiplication.
3:39
Now, that's the way I think about it. And sometimes these functions are quite complicated. These functions, these things can be quite complicated.
3:46
But the way to keep a clear head is just as I a picture in your mind's eye, I see one X accumulator coming from my right.
3:51
What do I have to do to update the equipment I just had?
3:59
And of course that accumulative then passed the left for the next X minus one in presumably and with the full left it's exactly the same of course,
4:02
except what you get. So just drew it, you get the phone left.
4:09
Again, there's my thing, but I'm going to focus on these elements going on to examine and now I've got the cash in my hand.
4:19
So the only difference is that this law here has already been collapsed to form an accumulator.
4:26
So what do I have to do? Which function do I need to get my update, my accumulator?
4:31
So I've got something in the case of Ford left, I've got to function is the form.
4:38
You give me the accumulators, one of the arguments and you give me the X as the other argument generally.
4:41
OK, then all I have to do is work out what that is.
4:47
So the if you think about the maps, the filters, that with the folds there's a pattern of recursion encoded in there.
4:52
And the lovely thing about using the maps, the first of all, I don't know,
5:01
I don't have to actually express the recursion explicitly in my programme because
5:04
it's done behind the scenes and that's what higher order functions give you.
5:07
It's a means of packaging up a common pattern or common patterns of recursion.
5:11
And all I have to do is parameter values, the higher order function with the right F.
5:15
And of course, in the base case when I've got an empty list that turns into a series,
5:19
I'm going to give it the F and I've got to give it the year and I'm done the following
5:24
will the rest of the work for me and somebody with maps and filters and symbols and so on.
5:28
All right. So we'll come back to this in just a minute because we're going to use these phone functions as we go through.
5:35
So I showed you some examples. And what do we do next?
5:42
I showed you the variation, which happens when it's really the question here is what happens if there's nothing sensible I can do with an empty list?
5:47
So there are some problems where it doesn't make sense to apply a computational net until there isn't, there isn't a meaningful answer.
5:56
A classic example is capping the minimum element of the maximum.
6:03
If if it's an engine, it's got absolutely no idea what the unit is, what what the what the value to return is in the case of an empty list.
6:07
So there's a variation called for right one and left one, which only work in the event of a non-empty list.
6:15
And it just basically means that there is no unit because there can be no units in general.
6:22
And so we looked at that and then I think I left you with a bit of homework, but go and play with the scan function and see if you can define those.
6:28
This might have been the last laugh, but it put up. If not, I'll go over just briefly again.
6:34
So the last I didn't actually come because I didn't do the asteroid today.
6:39
So other hand, functions, you know, about taking drops. So take do you remember what take is takes says something like.
6:44
It takes an eight take and it takes an eight and takes a list of items of some arbitrary type,
6:53
and it gives me a prefix of those, it gives me the first.
7:00
And if this is if this is some No N and this is Xs, it gives me the first and it gives me the first N items in that list.
7:02
Xs. So it's a sort of prefixing function and drop is a sort of suffix and function as a suffix throws away the prefix so,
7:11
so gropers does the opposite kind of thing. So there are very variations on this.
7:18
The hardware variations I think will take a while and drop well.
7:23
So instead of having it ain't to count how many elements we take, we have a predicate and the regular course is a function.
7:26
Somebody said in the ad the other day what the product is just a particular function which returns a boo.
7:34
So you can be and I'll give you a Bulbeck. So the idea is that if the predicate is true.
7:39
So in other words, when I take when I apply the predicates to one of the excuse, if I get true,
7:45
then that becomes part of the plot and I just simply focus on the remainder of the list.
7:48
So rather than counting in items to form the prefix, I keep building the prefix long as the predicate is true.
7:54
Other things, as soon as the predicate is gone false, then I stop.
8:01
So as soon as this is excuse me, false. In other words, if I fall down this case, then I could turn them into this.
8:06
So in other words, I don't because I drop by this straightforward exercise, you can you can write it having seen tape while it's easy to drop.
8:14
Well, now I'm going to show you. Right, because this is something that you should be able to use in this week's lab.
8:22
So what does iterates do is right. Takes a function and an item and it generates a list.
8:29
And the list consists of all items of the form like come here.
8:35
So if I say iterate. And there's more to this this event gives me the list X.
8:40
F of X and then F of O.
8:51
F of X. Oh, come on, won't let me draw a bracket there and then F of F of X and F, F of X and so on, and they say this is an infinite list, in fact.
8:56
So, for example, if they if the let's come down here and I get my control key to do the right thing,
9:07
if I so if I say it right plus and with say well what should we start,
9:14
start with zero then that is it's not I the success function starting with zero.
9:22
Then I get an infinite list of all the integers starting with zero. Which is great now just come back to the virtual board.
9:29
It does look like there's some potential redundancy because I've got two networks here and I've got another.
9:38
They're surely not sure we don't do it again and again and again.
9:43
Indeed we don't. So just to convince you of that. Supposing I start to think about what I'll geographically iterate.
9:47
Takes two arguments, supposing I draws a graph, there's my F, there's my X.
9:57
Well, this gets replaced by is that you overwritten with because it's mathematically the same.
10:02
It's the cons of looking at the definition. See the bottom.
10:07
It's the cons of the X.
10:11
With its rate F and then the expert gets replaced by effects on the next function call, so this becomes console X and this becomes iterate.
10:14
Well, Jordan grew up in Detroit F with F of X, so this is therefore the application of F to.
10:26
Would line up to the to that exit, and that gets replaced by above average for the whole graph, but of course this comes at the top,
10:37
doesn't that's just the normal for many people, that it's a get normal form and there's nothing to change that.
10:46
But I can replace the trait. Well, what does it do? Just apply the same rule?
10:54
Again, this becomes a cons of the X. Well, what's the X and now.
10:57
Well, that was the. So this thing in here.
11:04
That whole thing in this the subtree here, this is the yeah,
11:09
so that gets replaced by and I'll do it again if I've got room to see if I can draw it again.
11:12
This becomes well, that's the application of F.
11:19
To X, which is one, and now I get down here another call to iterate and this will go on forever, alliterate F with the application of F to the X.
11:23
Well, that's just the application of that now. Well, the X is now the after-effects of this push back up into the tree.
11:34
So it's no redundancy here because of the graft reduction, the graft simplification, the graph evaluation that is implemented in GHC in high school.
11:39
So everything that can be shared is shared. So in particular, this computation, the set of X in here is only ever done once.
11:48
Once it's been done once, then I can refer to it many, many times potentially.
11:55
OK, good. So what's this good for?
12:00
Well, all supposing you had an integrated function system where you started with some seed expression or some seed string,
12:03
and the idea was to replace each character in the string with the other string producing a longer string.
12:11
And then you took every character in that string and you produced in that other string.
12:18
So the idea is you can grow indefinitely these strings from an initial seed.
12:21
And the idea is that these strings describe a picture and that's what a fractal is.
12:26
Basically, it's an issue as it functions. So it's a very nice way of doing that.
12:30
You can expand the fractal as many times as you want. And the nice thing about returning the results in this list is the stuff here is
12:34
you get all the intermediate calculations that you might ever want to refer to.
12:41
So you might have some some see some seed that which might be just the stuff of a tree or something on the ground.
12:47
And then the next one might turn that into something that looks like that. And the next one might turn into something that looks like that.
12:53
Yeah. And you can start to grow recursive fractal structures.
13:00
And the longer you let it go, the more complicated the fractal becomes.
13:04
And you do as you sort of truncate this at some some number, maybe n o do it 10 times and we'll see what the tree looks like.
13:09
And then you render the image as a sequence of lines on on the screen using whatever colours you choose.
13:15
And if you change the rules of the game, if you change the expansion function,
13:22
this everything when you say iterate and F is the expansion function and you can change the rules of the
13:25
game by changing the and you get different tree structures or different different fractal structures. So there's an opportunity to play.
13:31
And I think there's a little competition this week for the best fractal. Ryan, you've got a question.
13:36
Yackety explain again how it expands like it branches.
13:43
I didn't quite get the function. Oh, well, this is the lab this week.
13:47
I think I'll leave it at that. And it turns out that this little thing down here is a string, some seed string.
13:50
And this is another. This thing is so. So you start with a string and then you you rende the string.
13:57
So there are rules for taking the strip and mapping them into lines and then you draw the lines.
14:02
So this might be some bass string as well. And then you turn that into Anasta by applying some function evidence that seems necessary.
14:07
So the strings have a longer. But all the F is doing is simply replacing the characters and this with another substring,
14:14
so and then you take these strings and then somehow you map the strings into lines, you map the strings into lines and you draw them on the set.
14:20
All become crystal clear when you read this back. OK,
14:28
but the other point of the discussion is to encourage you to use the iterate function
14:31
because this club is designed to exercise your application of horrible functions.
14:35
Very good. So this kind of the same.
14:42
So is it kind of the same as food left function where it takes instead of two arguments, it just takes one arguments and keep repeating it.
14:46
Is it the same as the fall, can you express the in the fall? Except it takes one argument instead of two because it takes each element.
14:57
Yeah, I'd have to think about that offline. Actually, the answer when people say, can I can I buy X using a phone.
15:05
The answer is almost always, yeah, yeah.
15:12
You can do anything with the fold. Might be contrived. I'm sure you can take that offline.
15:16
And I was thinking the breaking good. All right. So here are some examples I just showed you.
15:21
Iterates succoured zero, which gives me the infinite list of integers, starting with zero.
15:28
And because of his evaluation, I can just take a subset of those, maybe the first 10.
15:32
And that gives me this list. Of course, there are many other ways of just getting the same result.
15:36
I wouldn't use it right if I wanted the number zero. I just I've just used zero.
15:40
Dr. Tannhäuser. What I just said, of course.
15:45
But it just just by way of an example.
15:49
So if I repeated the title of a list like a tale of a string, for example, I get all the solium, all the suffixes.
15:52
Yeah, I stop the string itself, then the string with the first item removed and that was the first item removed.
15:58
And again with the first assortment I ended up down.
16:03
Eventually I end up down the empty list and which case I can't take the title of an empty.
16:07
So I've got to make sure that if I've got to take the right number of elements, otherwise I'm going to get an error.
16:11
But in principle you can generate all the suffixes of a string or a list that way.
16:15
And I've got the function even with the numbers, even if I give me some integers in a list, take while even of that list will say, well, is that even.
16:20
Yes. Oh, that can come out. Is that in here. Is that is that. No. So at that point you stop and even though there's another number in there, we stop.
16:31
So the difference between a filter. Even over, and I want.
16:36
Well, let's just say two, four, six, seven, nine, something like that.
16:45
So filter, filter, filter, process every element and asks whether or not it's even given me those Atari, whereas take while stops.
16:52
As soon as just placed that listings, let me tell you that again, so that that stops.
17:03
So even though there's another one in the list, because the bear actually the fact the seven is not even when we stop.
17:10
So you basically just got to that point, just chucking away the items in the time.
17:16
And Rockwell does obviously something similar. What will drop will do in this case if I don't change the list?
17:21
Right. So it throws away the numbers that they can giving me to the other end of the last year.
17:32
So one takes the numbers and stops and one throws away the numbers and then stops.
17:36
Good. And you know, when you come to I guess you would have done this last week or so, in fact, last week's exercise.
17:42
It's actually you you may be able to discuss this with you can tidy up quite a lot of the functions last week by using higher order functions.
17:50
So there might be the fact that there wasn't no if you wanted to remove white space from the front of the street, you know,
17:57
there are functions that will do this for you,
18:03
but probably space will just chuck away any white space and giving you the first space character, right?
18:05
I think that's an old hand is presumably. I'll take that as a yes, right, let's have a look at we'll just do this and have a break in a few minutes.
18:10
I mean, that's sort of obvious. But so the next thing is I want to talk about is binary operator extension.
18:25
So we know that there are operators like plus and time trying to append an accidental.
18:31
So these are binary functions. So they take two arguments and and generate a result.
18:36
Well if so, if you can have the operator works on two argue it's straightforward to see how you can generalise it to operate on a list of items.
18:42
So if plus for example, sums two numbers, adds up to numbers, if I,
18:50
if I want to sum the elements of what the function some or some of the elements of an arbitrary and arbitrary like list of numbers.
18:56
So what's the type of plus again, it's coming here.
19:02
What's the type of plus we know that plus as well.
19:06
I can add, I can add any two things, any two numbers giving you a third number and they see what more details about this type class later.
19:10
So these are these are these are things that can be added and multiplied and taken away and so on.
19:16
And well, the generalisation of that is just the sum function which says, well, okay,
19:21
okay, if you give me some numbers, give me a list of them, an arbitrary number.
19:25
And of course, I will then just add them all up. So an obvious way to think about doing that.
19:28
Well, if I do the pairwise so got the first two and then I add that, that the sum of those two to the next one and so on,
19:33
so I can sort of form these binary trees if you like,
19:38
and that's exactly the game are going to be playing in just another product is the generalisation multiplication.
19:41
So this will form the product of a list of them and is and is a function on a list of booleans.
19:48
I just want to play with, as you can say, something hand of true and false.
19:54
True as many as you want something like that, because whatever and concat is the generalisation of a pen.
19:59
So this the pen function here, the OR joins together.
20:08
Two lists will concat, will join and lists.
20:13
So you can say something like on Cat so I can have a list of lists, in fact list of a list of strings, a, b, c, d, e, f, g, h, I and other.
20:16
And actually there's a sort of identity.
20:28
And if I just have two lists and I can cut those two list, that must be the same as just type in the original lists.
20:30
I'm using the straightforward binary pen function. OK.
20:38
All right, so maximum in this economy, little looks like the old ones up because for all the ones above,
20:45
it makes sense if I've got emulous flying America to say what the answer is, but I can't tell you what the maximum minimum of an empty list is.
20:51
But think about that when we implement them. Right.
20:57
And there are some examples I'll need you to play with those. Now, how would you define some more product around the world?
21:02
And so let's look at product.
21:08
So here is as of last week before we studied higher order functions, this is the way he would have written the product function.
21:11
He said, well, OK, so product takes a list of things.
21:17
Well, either A's, whereas a nums or perhaps in this case list events will just simplify the type of just for the title.
21:20
I did actually just simplify the types I know in this case I've used the general types in here.
21:28
So in fact this slide is slightly outdated. To update this, this should say no, a list of eight.
21:32
Why not? It doesn't matter if this is a this is a version of product which were just on integers.
21:37
She said, OK, well, it just depends if I look at a list of things I know it's built from either the empty list constructor or the constructor.
21:44
Therefore, there are only two rules I need in my programme in this particular case, at least, editorial's what happens if I am given an empty list.
21:52
So this is where the left hand side is a pattern.
21:59
If you like all this specific, that's a pattern that says that is a pattern only matches empty lists.
22:01
So if you give me an activist, it will match the pattern and I commit to the answer one.
22:07
So mathematically, by definition, the product of an empty sequence of numbers is one.
22:10
OK, if it's in that case, if it's not empty, that's not the case.
22:16
If it's not empty, then I know the list will match that pattern,
22:20
in which case X becomes gets matched to the first item in the list in the access to the remaining elements.
22:24
So all you have to do, of course, is to form the product to the remaining elements and then multiply by the X and we're done.
22:29
And similarly with the end function underneath, in both cases,
22:35
you say there's a little decimal operator here and this operator here has been using infix mode as opposed prefix.
22:39
But of course I can bring the operator out.
22:46
I could say something about the multiplication of the X and the product of the X's, but something like that.
22:48
But of course, you know, it seems Matthei did you use the infix version?
22:58
So that's what I meant. But you can use either. Right, right.
23:02
Then. But notice that any case what are we do look at the pattern of computation in the base case, which is where it is.
23:09
Do something. Give me back a think a unit in this case, the one.
23:18
Because if I do some function, that would be a zero, wouldn't it?
23:21
And in the end, function in the base case is true. Again, that's the unit to.
23:25
And. OK, what about the recursive case again, in both cases, I'm taking some function, in this case the multiplication function,
23:29
it might be best to think of this prefix or index depending which way round your brain works.
23:37
I've got a function. I'm going to give that function to arguments. One is the head of the list and the other is the result of recursive call.
23:42
Guess what? Let's go down to the end here. I'm using the end function.
23:49
I'm going to give it to arguments. One is the head of the list and the other is the result of the recursive call.
23:54
Yeah, it's the same the same pattern of compensation, and that's the pattern of computation which is captured by Thode.
23:59
So in these cases, I can simply one way I can rewrite the product function is to say, well, rather than defining it,
24:07
using all these lines of code with these two, Padmasree, I can just use fold because that's the job of all takes a common pattern of computation.
24:14
I parameterise it with the right function and the right unit and out pops the very expression,
24:21
the very thing I'm trying to compute is a product of the axis.
24:27
So rather than writing what I just showed you here, one of like one line and just two fold,
24:32
right or left a fold of the multiplication function using what is the into the axis and similarly within easy peasy.
24:38
Good. Right now, just one of devotion is that we know that.
24:51
I can I can use either the phone right or the left, because this is associated.
25:00
I get the same answer. So given that I can choose phone right or phone left to do multiplication and addition and indeed the ends of the earth,
25:05
which one should we pick and why? Well, we've got to be a little bit careful.
25:15
Well, that's the thing, if I'm trying to do multiplication in addition.
25:23
It doesn't matter and there's no other I can choose either, but one thing we learnt the other day is that foaled left is potentially,
25:28
if not actually tell recursive and therefore you should use where you where you had the option.
25:36
A good reason for using the compiler can exploit teleportation.
25:42
No, I did point out one thing to you at the time and somebody else asked a really good question.
25:46
Is it really recursive because of the evaluation? The answer was actually if I use for.
25:51
No, it isn't. And I think I can demonstrate this.
25:55
I get the right numbers. So. Well, let me just.
25:59
Yeah, let me just go before I do that, just to remind you, I did this kind of conversation.
26:04
You probably have gotten it when we were looking for left.
26:08
And the implementation of what I actually do need to go to more scrutiny on the implementation of Foaled Left.
26:12
Where is it? So there's my phone right there, just happen to have that lying around, where is my phone left?
26:20
Is my phone left, right, sevenfold left? Do you remember that?
26:29
We started with folding a function with a unit into a list on taxes.
26:33
So we said only got to do is to grow. Remember this idea of thinking of these things as accumulated, but to grow the accumulated?
26:39
I think of that as an accumulated, which is initially the unit. And every time I go around the recursion, the accumulated grows by one another.
26:43
One extra application of using the occasion. Exactly the energy I just gave you.
26:51
So the question is, although this has got to recursive structure left, and so that is the old right hand side is the fault and nothing else.
26:56
And we know that. So we tell you we know that it's isomorphic to a loop that even loops into conventional programming languages.
27:05
Actually, in principle, this could be implemented as a loop. The problem is, because of the evaluation, this effort doesn't get evaluated.
27:12
Because of that,
27:22
you end up stacking up this enormous expressed version of F a view of X one and then F of that with X2 and then after that with Extra.
27:22
And these things never get computed until you pop out to the topmost level outcomes,
27:29
the two outcomes, that massive thing you want to do because it's now popped up at the top,
27:33
the computation and what you want to say, you're screaming at saying, yes, of course I want computing.
27:39
Can you see?
27:43
And so there is a way around this one, which is to use this magic function called Thole Left Prime, which has got a hack in it, which makes sense.
27:45
She makes this this thing strict when you pass this argument in.
27:53
So I can demonstrate that.
27:58
So let's just see, supposing I try to sum up use in the plus function using the unit as zero, like in some ways I can solve that problem.
28:00
So how about if I saw a really big list? Now let's just see what's really big.
28:09
Should we try a million to three, four, five, six? Has not done very well.
28:15
I think if I try it with an even bigger list, oh, it's done, it will done.
28:22
It's quite slow, isn't it? Try one more. So it's quite slow, isn't it?
28:26
And you'll see in the minute what slow is because it's a year.
28:37
So let's go back to the one we had before. Maybe I can change that to two. Can I change that to two without breaking it?
28:44
There's running out of memory because it's assembling these enormous. I go back to where I started that one there.
28:52
I think that was all right. OK, so it takes several seconds to do that, doesn't it?
29:00
Now, if I replace the phone with a phone left prime.
29:04
So rather than carrying these unobligated expressions around, it just evaluates them straightaway.
29:09
So plus of seven and one gets immediately replaced by eight.
29:13
Oh. Oh. OK, so the problem at the end of the last lecture, by the way,
29:18
is because I imported DataDot exotic name clashes, so I might just probably be able to do that now.
29:27
No, I can't do that because I because I've hidden the. Let's just go into be a.
29:33
I know how to fix this, but I don't want to change the fall again, so let's trifold let the public just get it cashed, actually.
29:41
Right. Let's go back to that one. Want to do you know about timing?
29:47
You can say do that and we'll tell you how long it takes.
29:53
Two seconds. So now I replacement for left prime ministership is noticeably faster.
29:58
Oh, baby. Oh, hang on, it's still broken.
30:04
What is it? Oh, is it sorry, no, I take it back, I take it back.
30:11
I just know what the problem is now. Sorry, I'm forgetting something vital.
30:20
Let's go back to bed so I'm in the right place. Right? So this thing is indicted.
30:24
Don't list.
30:29
I thought I reported it and I did it last week, I had to delete it because it was giving me name clashes, so I'll just go back and do that on GHC now.
30:31
It should be the case. If I do that and I'll just do so, we can time it again, it was to just over two seconds before, wasn't it, is point to three.
30:38
So it's substantially faster. So the good news is she really does do teleworkers optimisation.
30:48
It really does take this full time thing, takes this this these competitions, and it does implement them essentially as a loop as you would get.
30:55
So you get the full benefits of a Java programme, Python Sloper Java programme whilst writing beautiful high school functional code.
31:04
What should we choose for? And oh Hakone, you've got a question. We know that there's a four four hour prime.
31:15
Can we also, like, use the heck like what was the Hercules being used to force the evacuation?
31:24
Oh, that oh if you if you can't come in where it is, if you could even find the source code for this one,
31:30
it's absolutely not something we're going to cover in this course is this this is quite an advanced topic,
31:39
but you can force function application to be strict.
31:43
So you'll probably find, if I remember rightly, there's something like, you know, the dollar operator.
31:46
So I'm. You can say of.
31:54
I'm so sick of so, so sick of zero, or you can say suck, there's an explicit application function, it's just got very low, low precedence.
32:00
So anyway, you probably know about.
32:10
So I think you'll find the something like that somewhere in the encoding and that forces the argument to be strict.
32:11
And so, yeah, they get these bang bang annotations and that says, forget the passion for this all, just go away and do it as soon as you can.
32:21
So there's all sorts of things that as a use of the language, you've got control over.
32:33
But in this case, just just don't worry about because you're not going to need it.
32:37
Right. I think that's a new hand, isn't it? Yeah,
32:41
so basically the difference between the Fadell and full time is that that which basically is what that evaluates as you go instead of waiting for.
32:45
So this little this little thing in here, it arranges for that to be evaluated immediately rather than waiting to see whether it actually needs it.
32:59
Why doesn't it do that for fallout normally? Because that may not be what I want.
33:06
OK, it depends. Richard.
33:16
So whatever the heck is, how can it force you to do it, because without reaching the top of the stack, how can it even get the answer?
33:21
Does it? So the way I going to get stuck in this written books about this.
33:28
So so this is called if this thing is called a is implemented, I think would have thunk.
33:33
It's an expression which will evaluate if you want it to, and it's carried around, especially the data structure on the heat.
33:37
And so if you ever need it, it says, OK, go and evaluate the value of X.
33:43
So if it's true, it says, well, rather than putting fireworks on the heat, just do it now.
33:49
So it'll compute few weeks before. Invokes the forum the next time round.
33:54
OK, great. OK, right.
33:58
Let's move. Let's move on to another topic after the break. In a minute. I just want to just get one more thing.
34:02
So what should be used for and do you think? Well, the crucial thing about and is we want short circuiting, don't we?
34:07
So if you come to the whiteboard, if you say, let's just do this on the command line.
34:13
So if I say if I give you a list, true.
34:18
This is definitely not a true false, true, true.
34:22
And I want to do the end of that.
34:30
But so the way this is going to be felt, but the way this is going to get implemented, as you know by now, is that that's going to get by.
34:34
The fog is and is equal to fold. What's a fold.
34:41
Right, of that little operator using true is the unit into my list, Delta Dot.
34:45
That's the way it gets implemented. Right.
34:51
So therefore that that expression above gets replaced with essentially false.
34:55
And because it's right, it's because I've chosen the right associative fold.
34:59
That's false. And some term, which of course is the remainder.
35:03
It's going to be true. And I put the brackets in again.
35:07
This is going to be true. And and then the unit pops in, which is the true bang bang.
35:11
And that's why you get false. That's exactly the expression that's computed when you do.
35:17
The implementation of and using foaled right now, if I used four left at,
35:23
the reason why I want it this way around is because should because that's false and
35:28
because I know that we discussed the the implementation of the little ampersand operator.
35:32
The unmanned operator is it doesn't matter what that is. If if the first argument is false, the answer is false.
35:36
So we can short circuit the computation. And that's exactly what we want.
35:42
In fact, if we didn't use far right, we wouldn't get any short circuiting.
35:46
So just to demonstrate that supposing I wanted to do this instead of that, I will put.
35:49
Do you know about repeat, we come across this yet repeat eight generates quite a large number of eights and infinitely many large number of eights.
35:55
So if I said end of a list consisting of false. Com was doomed to repeat true.
36:04
Repeat true. And I say that guess what I get.
36:12
Cutting it short circuits. Now, if instead of using the end, I'd use the fold left.
36:17
What do you think would happen? OK, let's try for a left of end using truth.
36:24
You cannot do that yet.
36:29
So in other words, it's never Terminix because it's constantly trying to get down to the basics so
36:33
that it can assemble back up this this sequence of these accumulating units,
36:36
so to speak. Get it. Uh, Catherine, question.
36:43
So can we use for right one, it's of fault, right, because you can use the right one, but the trouble with all of that to do to calculate minimum,
36:51
if I say what's the minimum of a list of numbers, we know what that means and we can.
37:04
So if I try to remember the discussion, if I tried to rather using fault.
37:13
Right. And I say use the main function, what on earth should I put in there?
37:16
Now, in this case, you might get a guess because I tell you the list of things, but in general, Minimum's could calculate anything which erodable.
37:22
So I've got no idea what to replace the question marks with. So it never makes sense.
37:29
You just know if it doesn't make sense to ask for the minimum of an empty list.
37:33
So it's the same as the asking the question, what would when you get to an end to this, what should you return?
37:37
It's the same question we don't know. So if that for that reason, then we use foaled right.
37:42
One which only works with works without a union disconcerts the Yefim between the one, the two and three.
37:48
So what's happening in my short list a little bit,
37:53
what's actually happening in here is Uncalculating Min of one and the exactly the same folding structure, the two.
37:57
And guess what? Yes, the min. Oh wait a minute.
38:03
Can't have the middle of three with a unit because we haven't got a unit so that just becomes Aminov two and three.
38:06
So it's the same thing except there's similar things that there's no unit.
38:12
So that that is exactly the same as the expression of. So you've got a choice between four left and right, I guess, which one you want.
38:18
So your question was kind of useful, right? One with the ampersand and.
38:27
Well, I guess my my example was what was it true blue constant to repeat.
38:34
False, false, false, condemned repeat true wouldn't it, to get short-circuiting false on to repeat true.
38:42
And yes I can short-circuiting just the same way. The trouble is I wouldn't use fold like one because I want to be able to do that.
38:53
Because that should be true and of course, there isn't a rule for that,
39:01
if I was followed by one of useful right now, I've got to give it the I know the universe and it's true.
39:05
And that's where I get the answer. That's why you don't use the right one.
39:11
In that case, is that OK? Excellent, right?
39:15
So just to wrap this up and then we'll have a little break, I think we'll wrap this up.
39:20
So so we've got some well, for example, we had some product and written in this sort of way.
39:24
And then you think, wait a minute, that's just the same pattern of recursion encoded explicitly over and over and over again.
39:33
Let's use the phone. So here we go. And here are the phones.
39:40
You pick you pick the left associative one because it's well, I should say fold left prime here, shouldn't I?
39:42
I should update my slides so the fold left will give you tell recursion and therefore a faster implementation.
39:49
The fold right. I want for the end and the all because I want the short circuiting and I also want the fold right.
39:56
For concatenation because I don't want to, I want to be, I want to concatenate, I can castanet over an ever growing list.
40:02
So what does that mean if I say I've, I've got some this is what I'm doing.
40:10
I'm trying to do this. And this is what Concat is doing exercises, this is a list, obviously.
40:16
Which one should I bracketed? Well, I don't want to bracket it this way.
40:29
Because if I bracket it that way, by the way, there's there's obviously a.
40:35
I tried to break it, there would be this unit on the Internet, of course, but I wouldn't want to break it that way because why not?
40:41
Because we know that this and this appending this this appen function process is its first argument.
40:46
So if I say X is a penny wise, it walks down the axis, doesn't it, in the end of the axis and includes the wires onto the rightmost then.
40:54
So if I did this way around, I start off with a list of links and one when I have to go to that,
41:01
and then I'd have to do that, which is a little and one plus and two,
41:08
which means I rescanned the first Fluminense one elements again and then I had to go for this one, which is one percent, two plus and three.
41:12
It's got the wrong complexity. What I should be doing is bracketing it the other way and saying X is one appended and then X is two and so on.
41:20
And then I only process this once. So I'm only ever concatenate a short list onto big list.
41:32
And that's that's what I want to do, because I know I don't ever need it to dismantle the whys when I'm joining Axis onto the front.
41:39
So that's why we would choose the far right for the concatenation.
41:46
And as I've just described, the the obvious way to do this is for left of.
41:50
All right, we must use useful that because we know it's potentially recursive.
41:55
Of course, there's a I put the prime on there to get what I want or any quick questions and then we'll have a break.
41:59
Why do we use feel like why can't we just use polar prime instead of full, in what cases we want to use for our.
42:08
Both our prime instead of Thode, oh, yeah, because it's quicker to evaluate stuff.
42:18
Well, I don't want the. I don't.
42:25
Um. You have to be careful, I don't.
42:29
Whatever you do, you don't want to evaluate the.
42:33
I've lost I've lost the size that if you're searching an ampersand into a list, for example,
42:37
you don't want to force the evaluation of the top end of the list because then you wouldn't get the short-circuiting.
42:42
But it would be reasonable to short circuit, you could make the first argument straight, I guess that wouldn't cause us any problems.
42:49
Let's let's just leave let's just leave if the timing is I certainly I certainly here would choose the Fogler trying to get the to get there.
43:00
Yeah, well, I'm using a left associative. I definitely want to do that because I don't want to keep me like this ever,
43:08
ever larger and growing unit to come accumulator with a fold like the only benefit you
43:15
get from short circuiting its first argument would be would it be fairly minimal,
43:20
I would say. So what we're specifically trying to do is to enable Short-circuiting to happen,
43:24
which means I've got to I've got to use the evaluation to at least evaluate the second argument of the ampersand when he gets inserted.
43:31
There may be a better answer that I have put upon Richard, before we go,
43:41
so what or maybe using with the into the fold in the same reason, because I want to short circuit because.
43:45
But I would also also get it the first ones, too.
43:55
Well, no, it's OK if the first ones true will short circuit because true or anything is true.
43:59
So, in fact, the definition of or says something like, if I've got a boo or B for anything, I'll just give you true.
44:06
If I don't need to name the bead. Don't need to name the be.
44:15
I can just give an underscore. So that's the first rule. So there's the short circuiting happening, is that right?
44:22
Yeah. Oh, OK. Let's have a break. You. OK, let's resume so we have this table, can you someone just put a hand up just in case something is broken?
44:28
Can you hear me? Thank you very much. Very good. Right.
52:40
So we end up with this table having picked the left, left and right versions of the voting functions,
52:45
so there was a question to think about what the previous question actually meant.
52:56
So I think you said something like, why wouldn't you use foaled?
53:01
Right. Pry? I fold, right. I don't know. Are you were you suggesting that there is a far right problem and we've got the option to use a poll?
53:05
Right. Because I don't think there is. And but you're saying if we were to, would it make sense to define our own phone?
53:13
Right. Prime function. So I guess.
53:20
I guess you could do I just don't know that I'm just just pondering this.
53:25
So if you say fold. Right from.
53:31
I'm sorry if you say F unit X's, so we know this gives F of X one with F O Su and so on, and then at the end of this log,
53:36
you get F X and we all, you know, because if there was a substantive one, so absolutely.
53:53
We would not want to make the F strict in that argument.
53:59
So I think the only sensible way of making phone right strict would be to make it strict in that argument.
54:05
And then I don't think there's anything much to be gained by that.
54:10
Yes, of course you could. You can make any function strict and you can force the argument.
54:14
You can force the X wonder if you really want. But even then, you know, it depends on what the F is,
54:18
maybe F is something it doesn't need the money at all, in which case you wouldn't want to force it.
54:25
So who knows? But anyway, I don't know of full prime, but I don't know why you would actually usefully use it.
54:29
Something that was just me saying again, what I think I said just now, I ask, go back.
54:36
So what's next? Is carrying a partial.
54:42
So we know now that power what is one one flavour of higher order functions are functions which take another function as an argument.
54:45
And we've seen that in the types. When you look at the type of sun to map, the first argument is function type.
54:52
It says, give me a name to be listed, I'll give you a list of B, but of course, so is another way we can use how to function.
54:57
And actually when we invoker function, we can generate a function.
55:04
So in other words, one function can compute and deliver as its result, another function.
55:06
You might think, well, how can it do that? Well, there are several ways that the classical ways to use a thing called partial application.
55:10
Now let's go right back. Almost election one election to when we looked at functions like plus here's a plus
55:17
function adds to into generates a third and we rotate plus x y with the gaps,
55:23
the spaces in between the function and the two arguments. And I say, trust me, we'll come back and look at this again later.
55:28
Well, here we are. So you might have said you might have thought at the time, well, let's just get to the bottom here.
55:34
So I'm. Do you to say what we make plus sorry, we'll make plus work on pairs of things.
55:42
So plus of X, Y is X plus Y Y, you know, that's the way I would write in.
55:49
Probably wouldn't put the spites in would I, if I saw this in a sort of Python programming book or something, or maybe a Java programming.
55:53
But yeah, that's the sort of thing I guess you'd be used to saying.
55:59
But of course members at different functions got different time. So the type of this one, perhaps this if we just talk about INTs rather than nums,
56:03
but this might take a pair of pants and generate some nothing wrong with that.
56:10
It does. It's fine. But I said in typical high school, the idiomatic way of doing this,
56:15
and this is a very good reason why this function should operate on pairs, is that we just instead do that.
56:19
And I said, just do that for now and we'll come back and see why. That's typically what we do, giving us the.
56:26
So I said, just put the mike. That's that's right. So here we go.
56:31
So why do we write intro into it's not considered to be a pair, for example.
56:36
And the answer is that sacredly, what's going on here is that this plus function is not a function of two arguments.
56:42
I was lying in line for three weeks plus is actually a function of one argument.
56:49
The X and when you give it the actually gives you back another function which is
56:56
expecting the Y and haven't got the Y will then add the X in the war together.
57:00
So in other words, what you're doing in this definition is introducing two functions, not one.
57:04
Right. So to say that, well, if if what if what if what I've said is true,
57:10
but it must be the case that something like plus four is a meaningful expression
57:15
because it just takes one argument and gives me a function as a result.
57:19
That must be the function which adds for lots of things.
57:23
Right. So once the FDA's been frozen, I've got another function, a function of a single argument y which will compute for plus Y.
57:27
Right. So the other thing to think about is the if what I've said is true, then surely that means that the type expression, the type,
57:35
the type signature for the plaque function must be bracketed that way because only if it's bracketed that way can you see why.
57:42
Then it takes a single point and generates a function from constituents.
57:49
And here comes the end, the X rather for example, the X is event.
57:54
And this gives me back a function which given the Y will give me back an X plus Y.
57:58
So the bracketing must work to the right, slightly counterintuitive in brackets, to the right, because function application is left associative.
58:04
What I mean by that, if I've got a function applied to an X, Y and Z from what I just told you this, oh it's a three document function.
58:14
No, it's not a one argument function which generates another one document function, which is another one argument function takes in one time.
58:25
So this is actually generated using three functions. So that must be a perfectly valid thing.
58:31
Yes, the F effect is a valid expression and that's going to give me a function back.
58:36
And if I give that function, the Y, that's going to give me a function back on that function.
58:42
We give him the Z will then continue compute F of X, Y, Z, according to the rules for F, so that that's left associative function application.
58:47
And for that to be consistent with a type signature, the type signature for F must go the other way round.
58:56
I must practise it the other way. So you give me an A. Which is the type of the X and I'll give you back a function which expects the B,
59:00
which is the type of the Y, and that will give me back a function which given the C,
59:10
which is the type of the Z that will eventually give me the results type whatever F of X, Y, Z and I give it away and they will compute.
59:16
So that's the type of the type of the the function of that complexity given A, B and C.
59:24
The important thing is to remember there have been one at a time.
59:31
Right. So well it plus four is the function.
59:36
As for two things, surely I can I can map this function over a list of numbers and they will add four to every number.
59:39
Well, lo and behold, I'm going to do it for your line because you probably don't believe this if you're not playing with this yourself.
59:45
Let's just get rid of that lot. OK, so if I say maths so well, let me just define plus just as the word says,
59:52
I've got plus so X and Y with X might be in my script, I don't think it is.
1:00:01
So no surprises in maths plus. Well let's put the partial application plus four over a list, one, two and sure enough to add one to each one.
1:00:08
So why is it doing that? How is it doing that. It looks like Magic four.
1:00:20
Well what is map to map says you give me a function, I will apply that function to every element of the list.
1:00:25
Let me make it slightly shorter.
1:00:30
So what is actually being generated there is this list, which is OK, so I'm going to take plus four and I'm going to apply that to one.
1:00:32
I'm going to take plus I put the function in brackets just so you can see it clearly.
1:00:41
I'm going to apply that to two and I'm going to get plus three plus four and apply that to three.
1:00:46
And sure enough, the same answer. Yeah, but I've just told you, the function application is left associative so that.
1:00:54
It's exactly the same, and as if I were an F, X, Y, Z,
1:01:04
so I can actually own the brackets in the exam room and I can instead of I'll just kill the brackets and out pops the
1:01:08
expression I would have written if I put the pluses inexplicitly in constructing that list without using the matricide.
1:01:17
So I guess the only tricky thing about this is that once you remember,
1:01:26
I guess once you remember that something space, something in has always been its function application.
1:01:32
So this this little space in here between the bracket and the one, that means the application of the thing in brackets to the argument.
1:01:40
In this case, one juxtaposition means function application.
1:01:47
And we know that we can safely omit the bracket. So plus four in brackets applied to one is the same as us for one, and both of those mean five.
1:01:51
Here's another example of what's going on here by mapping a partial application of the ELLAN function.
1:02:01
So this says, well, I'm looking to see is e an element of any of these strings?
1:02:08
So the E is frozen in time almost. So this is the thing that's fixed, so I partially apply the alarm to these.
1:02:14
This is this is the function LMI. This is a function is given a string will give me a true if the string contains a enfolds otherwise.
1:02:21
So there's no Ian. No, there is no. You know, again, there is in the end.
1:02:29
Yes. I get false. False, true. All right.
1:02:33
So what's happening with plus an alarm here is we're only giving it in this case, one of its two arguments,
1:02:39
because in general, one of its many arguments may be giving it two of its five arguments.
1:02:45
All of these are called partial applications and partial applications and function Haskell and other functions.
1:02:49
So once they're constructed a partial application, it's a first class object.
1:02:56
So this thing plus four is a first class entity and I can pass it around the programme.
1:02:58
I can take that function and give it to another function that can give it to another function. And what can it do with it?
1:03:02
Well, because it's the function of the consensus builder was apply.
1:03:08
It was what the map function is doing is applying the passport to the one the three in the.
1:03:10
But nonetheless, the important thing is to remember that functions are first class citizens,
1:03:16
the only thing you can't do with the function that we've seen so far is you can't compare them for equality.
1:03:20
I mean, there are other things you can't do, but that's certainly one of but in many other respects, they're first class.
1:03:23
Right. So why is it occurring just a small side?
1:03:31
Well, because the man the man who invented it. Well, I think yeah.
1:03:35
Yeah, maybe, maybe Haskell carried did invent it anyway.
1:03:39
So supposedly Haskell Haskell, Carrie Haskell, the B stands for, by the way.
1:03:43
So this chap called Haskell Brooks Curry invented this idea of replication and that's obviously the origin to the name Haskell.
1:03:47
So there you go. OK. All right. So that's how partial application of prefix functions, workable system of examples in a minute.
1:03:53
But just as an aside, of course, we've got these infix operators floating around the pluses,
1:04:01
the minus, the times, the powering, the division and so on. Well, those are functions, too.
1:04:05
As it turns out, there's a special syntax in Haskell, but partially applying an operator.
1:04:09
So this is the reciprocal function because it's one divided by and there's still a gap in there.
1:04:13
If I come to the virtual whiteboard to make this clear, if I've got something like that and that.
1:04:20
So there's a one in there, wasn't there? Well, so imagine if I draw like that.
1:04:29
So if I write one over seven, that means one of us, but one over.
1:04:33
Won over nothing, we just the brackets think of that as a function with a gap in it, as a sort of box in their support, and that therefore is a box.
1:04:38
That box is waiting to be filled by an argument.
1:04:47
So if I put the seven in there, I could give this a seven.
1:04:52
And that will simply put to seven and I get the one over seven back again just to just try these things out.
1:04:55
You know, you can't break the system. It's not going to object to you trying things out.
1:05:00
So one over is the reciprocation functions. If I get it seven, I get one over seven.
1:05:03
And similarly with other functions like what's this function? This is the say, this is something equal to zero.
1:05:08
Well, let's give it to something. And the answer is false. This is the function that says another way.
1:05:15
Right. I can put the argument in any position because it's I guess so is seven is the function seven equals.
1:05:20
This is like this asks whether something is equal to seven percent.
1:05:27
But the argument the other way around, of course that's true now because seven is equal to seven.
1:05:30
So imagine the seven being plotted into the individual box.
1:05:34
So here to spare the spare boxes on the right of the equals and here the spare box is on the left of the equals.
1:05:36
So that's as if I'd written in the let you in as if I'd written seven equals equals zero.
1:05:44
Which is why we get the false. All right, so not to ever do this, but it turns out that's the head function because you give me a list,
1:05:50
a list index, the position zero is the head of the list.
1:06:01
But of course, when it is right to use head, i.e. not as a substitute for pattern matching, when it's right to use head, then use head.
1:06:05
Don't use Plint zero, but just explain just a map, I guess, to explain the point there.
1:06:14
So by all means, take the hand end of a list of string.
1:06:20
These are forms, some acronyms. Now, what was the focus on random access memories and.
1:06:24
It was in the slides, so here are three strings. So my people just apply to each of these three strings and I get I get run.
1:06:30
And yes, of course, if head is equal to zero zero, please give me something.
1:06:41
Index to zero must give you the same thing. All right, good.
1:06:48
So some examples of that. You know, let's apply that function to every element.
1:06:54
The list, this, for example, zero for all. True, false, true.
1:06:59
And I can square this is the square and function, presumably because it's got it's got a box to the left of the parenting.
1:07:04
So but the one the two, three in the to the left in the parent function.
1:07:11
So I get one squared to square crispbread for square. This is this index is these three lists opposition to what the two does take.
1:07:16
Well what does this do. So it's right. Plus three goes one four, seven, 10, 13, 16, nineteen twenty two and so on up to infinity take well.
1:07:26
So this thing is well this is the function which is true if a given item is less than twenty and false otherwise.
1:07:36
So take while we'll give all the elements of it right,
1:07:43
plus one little less than twenty and throw away the remainder, which is why I got this this briefing.
1:07:45
So this is a prefix forming function, if you like.
1:07:50
And what I just want to see so much of this says, are you even.
1:07:55
Oh, I guess. So it doesn't.
1:07:59
Well, it sort of does, isn't it? So I take this one to 10, I map this function over.
1:08:05
So that's one to two more to three more to and so on.
1:08:11
So this is either going to give me a one or a zero is sort of thing numerically.
1:08:15
And filtering not equals zero just gives me all the one. So it's all the ones I get back into the it's a one for every odd number in that list.
1:08:20
How about that. And that may just be what you need to do for said problem or whatever.
1:08:27
OK, so functions are first class, as I've said. And in fact it's an interesting insight because we're going to use this in the minutes.
1:08:35
So we've got to keep a clear head this week and next. The notion of functional composition itself can also be expressed as a function.
1:08:42
So what do I mean by that? Well, there's a little operative built into the problem called DOT,
1:08:50
and you will know from your it's basically supposed to approximate this little symbol here.
1:08:55
You say mathematics, the maths textbooks. It's called the function composition.
1:09:00
Simple. So the idea is that you give me two functions, FMG. And then this is obviously the way the maths mathematician might and you give me an X.
1:09:05
This is the same as or this this should reduce to F of G of X.
1:09:14
That's what composition means.
1:09:21
So this thing in here being the composition of FMJ must itself be a function that is a function which given the X, will give me an effigy of X.
1:09:23
So composition. This thing in here must be a function which takes one function and another function and computes a third function.
1:09:32
So it's going to have some weird type.
1:09:45
And if you know, but we say if you are just on the type of composition you want to function programming perfectly, possibly some truth to that.
1:09:46
All right. So here's one way I can write it. And this is the Albie's about it, Haskell, I can say.
1:09:54
Right, OK, just in the same way that I introduced other infix operators and define them earlier on, I forget the examples that we looked at.
1:09:59
I haven't included the associativity in the precedence of the operator that they are not operating here, but you can look it up.
1:10:07
But anyway, having done that lot, how do I define composition and say, well, f dot g the composition of energy is another function.
1:10:13
H where. Oh, how do I define what X is just a function like any factor is a function.
1:10:21
Then I need to say something. Let's give it excuse me FFG of X.
1:10:26
So that's one way of doing it, which is to name the composition actually as H and then define what is and how do I do that one as well.
1:10:30
And I could use that expression I guess, but same thing. It turns out that this is also about syntax.
1:10:40
I can do that and it turns out and so is this.
1:10:46
So the slightly annoying thing about this definition is that I've got to come up with a name for the function representing the composition of G.
1:10:49
And you think, well, I don't really need to name it because it's just a function of X.
1:10:57
And so Haskell has this beautiful mechanism called the anonymous functions, which many other programming languages have stolen.
1:11:02
And in fact, Haskell stole it from a thing called the Lambda Calculus.
1:11:07
So it turns out that this little backslash here is an approximation to the lambda symbol, Greek symbol Lambda.
1:11:11
So because people generally don't have this, you know, the best thing they could come up with was that, which is pretty good.
1:11:18
So this is called a lavender expression.
1:11:25
So this says, well, f dot g, the composition G is the function of X, the anonymous unnamed function of X, which computes F, G of X.
1:11:31
It turns out these lambdas are quite useful. We may we will come back and use them later on when we start looking at monads.
1:11:43
But there are there are other ways of doing it.
1:11:50
So if you don't want to have the name that you should be learning by now, naming things is really hard.
1:11:54
I mean, we're good names. So lambdas are a perfect opportunity to define functions without having to make a name for them.
1:11:58
Now, what about the type? Right. Look at the thing at the bottom of slide 109.
1:12:05
I'm going to kind of draw this in the diagram. I'm going to draw this back on the virtual whiteboard.
1:12:10
Let's see if we can see why the type signature on the slide there is the right one.
1:12:16
So if. That G is the composition of FMJ, just remind ourselves.
1:12:21
You say you give me an X and this is the same as as if you never give X, that's one way to find it literally using equal.
1:12:28
Right. So now so just this is there here's the curiosity. Given the X, it applies first and then gives the result of that to the F.
1:12:37
So if I say if I draw my dog, I'm left to write, I could draw the other and draw Left-to-right on incomes.
1:12:46
My X this direction has one function is the other function.
1:12:52
The first thing I do with the X is I give it to G artpop Geewax and I give that to F.
1:12:58
So outhere should be Giovanna's, obviously, right now, let's write down some types,
1:13:05
instead of writing the names of the things coming in, I'm gonna write down the titles.
1:13:13
Well, if that's A, that's a B and that's a C, let's see where this takes us.
1:13:16
Right. So so this is the type of the things coming in.
1:13:21
The B is the type of the things go between the G and the efficacy of the type of things going this.
1:13:24
Right. So this function, the composition function takes an F and a G.
1:13:29
So therefore the type of the composition says, well, you give me an F F in this case as a function from B to C,
1:13:32
now I have to bracket that because remember the bracketing works to conform with left to search the function application.
1:13:41
So you'll see what happens if it in just a minute.
1:13:48
That takes a function F, which is type B to C, was it to say we can see from the diagram this function that takes a B turns into a C,
1:13:53
so that's the, the second argument it takes is the G, which is a longer bracket.
1:14:01
Again, this takes an A and produces a B.
1:14:05
Why is that. Because you can see that on the X and the result is FFG of X.
1:14:10
Well the composition is just that box there isn't it.
1:14:15
So draw a box around the composition that is a composed G.
1:14:18
And this takes an A and produced does it say so, hence the type of the composition operator.
1:14:23
Now, if I just written the Arrow C are A, B or C, of course, if I don't put the brackets in, Haskell is going to bracket this.
1:14:31
Which way round it's going to Brackett's, that autodidactic left the safety function application.
1:14:43
It's going to Brackett's it like that, isn't it? Which is completely wrong.
1:14:49
So for that reason, you have to put the brackets where you mean on the one on the end is OK.
1:14:57
I can actually optionally leave us when they leave this one out. But actually there's something just really weird about that, you know.
1:15:02
Give me one function and another function. I'll give you a third function. So it just seems to be all that's the same thing.
1:15:10
Just seems to be much more sensible to put the brackets in there, although it doesn't mean the thing.
1:15:17
Right. So I'll come back to so if you understand the tough competition,
1:15:23
then you've really got it and you haven't got the top competition, go away and play with things on the.
1:15:27
Come on, I'll show you some examples in one play, play, play. And then you'll hopefully begin to see why these types of.
1:15:32
Right, so what can we do with this competition thing? Well, it enables us to simplify some definitions.
1:15:41
You know, it's it's not rocket science and it doesn't totally transform the programme.
1:15:46
It doesn't change the complexity as far as I can think anyway.
1:15:50
It just gives us another way and sometimes much more succinct way of defining functions.
1:15:53
So here's a little example. So they're not no function. Well, given the list that X is, it asks whether it's not empty.
1:15:58
So it applies the null function, which gives me a true or false one, and not just in of the boolean.
1:16:05
So you look at that and you think, oh, wait a minute, wait a minute. That's something of the form F of G of X is what, F object X?
1:16:10
So I know what f G of X is. That's the composition of F Top G applied to X.
1:16:21
This is why is that reminder. Yeah. After G of X is the same as F dodgy separate to the X.
1:16:24
So if I tried this back in that direction, I can rewrite the not null function as the composition of note with no.
1:16:34
So this is a function which computes not null given an X therefore give you the X's.
1:16:41
That gives me not Alexis. It's the same thing and similarly, what about this one here?
1:16:47
This is a bit more complicated because is the partial application going on here?
1:16:53
So perhaps I'll copy it onto the I'm just copying onto the ball while you stare at that.
1:16:57
So what I got not it was zero access.
1:17:04
All right, so you think, oh, well, I can't get into the form I'm looking for is anything of the form F, G of X?
1:17:09
Then I can transform that into FWC. And give it the axe.
1:17:18
Well, I can't see when ah, but wait a moment, it's left the safety function application.
1:17:24
Let me put the brackets in. So let's assess the function of the map equals equals directions is actually equal to that.
1:17:27
And now I see there's my head. There's my G.
1:17:35
And there's my ex, so to speak, on this Panopto, this is the same as and.
1:17:41
Dot does the F dot g, which is and dot map equals equals.
1:17:47
That's the partial application of map.
1:17:53
To its function, but it hasn't got the argument yet that comes in later by virtue of the definition of the DOT, the composition.
1:17:56
So that is the same that. So which is why you see that.
1:18:03
And you think, well, what did I buy by doing that? Is it really worth it?
1:18:12
Well, hang in there next thing, intentionality. Now, you know from maths that if you can prove that I've got two functions,
1:18:17
the only way I can show that are functions was to show that absolutely every value of the domain of those two function is X equals J.
1:18:27
And if I can show that, then I think what if I just think of this is a Haskell definition of X equals G,
1:18:34
because it literally does mean for all except of X equals G, because the left hand side equals right and side.
1:18:39
So if I got that, I can just cancel the exercise,
1:18:46
because it must be that F is cheap and of course we know the functions of first class things in high school,
1:18:48
so I can simply remove the excess is an optional thing. I don't have to do it.
1:18:54
But can you see I can take something like this. There's my F of X equals G of X.
1:18:58
The G happens to be a composition not forget.
1:19:05
That is just a thing in brackets and therefore I can cancel the X is because for absolutely any list it's not this,
1:19:07
this rule here does not say oh well for X is where the third, the third element is seven and all the others even this rule applies.
1:19:14
No it says for absolutely any list xs it is implicitly for all Xs not null Xs.
1:19:22
It's the same function as not Alexi's and therefore not now is the same function Panopto.
1:19:27
No. And in Haskell because functions are first class things, I can just write literally that.
1:19:33
And there it is. So that's one reason that that's a nice reason why it's worth having compositionally your fingertips,
1:19:41
because composition combined with exceptionality means I can sometimes produce these beautiful,
1:19:48
tiny, very succinct and actually quite clear definitions which haven't got all the bundling apparatus of our names and pattern matching,
1:19:53
floating and whatever else. And this is called point free, by the way.
1:20:00
So for some people working out how to express any function point free becomes a bit of a hobby for some people, an obsession.
1:20:03
In fact, there's there's an entire programming language where the only thing you can do is the right people.
1:20:11
It's called F.P. I wouldn't recommend you used to. This is kind of an experimental language, but quite a lot of fun.
1:20:15
Right. So it looks really weird because you think so. Oh, what's the type of.
1:20:23
Not now. Well, not now. Says you give me a list of ages and I'll give you back a boolean.
1:20:27
And that is why that is its most general topic, isn't it? You know, you give me a list of not giving back about it, I think.
1:20:34
So it's expecting a list of. Wait a minute, where's the list of eight? There's no age.
1:20:40
There's nothing on the left hand side. The programme has made a mistake.
1:20:44
No, they haven't. They just expressed this at the function level.
1:20:48
So not now is a function which is expecting an excess or some argument, whatever name they give it.
1:20:52
And it's just going to give that argument to not don't know. So it kind of works the opposite way around to intentionality.
1:20:58
Well, if I can put the axis back, you just have to think. But it's not that there's a mistake in the programme.
1:21:04
There is a gap there. It's just that this is not now is a function which given a list X is well, do not know X's.
1:21:10
And similarly with the old zero from the bottom. Very beautiful.
1:21:17
Now, if you think about it, if I go back to this little table that I left with before the break, oh my goodness me, look what we got.
1:21:23
We've got F of axis equals. Well, just to make sure that we make sure.
1:21:32
Well, actually, this is the same thing I've got. What was it?
1:21:37
Which one was it? He started with some of axis. So some of axis.
1:21:41
Is full. Did we do the photo left?
1:21:50
Yeah. What do you do now on the virtual whiteboard? I will update the slide in as we speak and I'm going to use both prime,
1:21:55
because that's the one that actually does the tell recursion optimisation for me.
1:22:05
And there's the function this the unit as the Xs and I claim that is of the form F of X equals.
1:22:09
So just to verify that, let me put the brackets in.
1:22:20
So left a social function occasion, so that goes like that, that goes like that, I could even bracket the fallout from.
1:22:26
But I mean, there's no need to do that. And lo and behold, you see F X equals G of X, and therefore some must be equal to.
1:22:35
Well, I literally can write in Haskell. Some is equal to full.
1:22:45
That prime plus and I've just basically taken that bracketed term above and
1:22:53
just unpack the brackets now I've just got rid of so there's an is you know,
1:22:59
I've just got rid of the axis. So it's a one way to think about it. Just like take the take the detonator, cancel the axis left and right.
1:23:04
And indeed, if I've got a function. F of X, Y equals G of x, y, guess what, let's put the brackets in.
1:23:12
And now I can cancel the whys, and that tells me that makes is G of X and then I can cancel the access and that tells me that I was G,
1:23:23
so I can cancel more than one argument if I so long as they're in the right order. I sort of like thing.
1:23:32
Marvellous. All right, so let's see. There you go.
1:23:39
So that's what you'll probably see.
1:23:47
I haven't looked at the property for a little while, but that's what you'll probably see or something, but it's not in the property elsewhere.
1:23:50
You'll see this this idea of using partial application combined with intentionality to give these beautiful one liners.
1:23:55
So the sun function is the function foaled left plus zero. And but both of those are functions expecting a list of numbers.
1:24:02
And and what will happen on the right is the list of numbers will insert the plus and put the zero on the image that would just add them up.
1:24:10
So went down the list. Excellent.
1:24:18
So just to wrap up and then perhaps we'll do a Q&A,
1:24:23
I'll give you a little break and maybe we'll look at some more examples after the break or something.
1:24:28
Who knows? Here is a version of the square root function that we wrote earlier.
1:24:34
Do you remember this? What do we have? Perhaps I can ping back to it, but on slide 13.
1:24:41
So I know. Get to go back to somewhere back here. It was it we were doing recursion work, which was a simple example.
1:24:47
Well, others are square root function. Remember how this works. This is the Newton method for calculating square root.
1:24:55
So just refresh your memory. We start with some initial approximation.
1:25:02
And I think we said, well, just arbitrarily we'll pick out because there were two. But it could be to start with one or 17 or some other number.
1:25:08
That doesn't matter. And then we're going to go to phase one and then we're going to get to see how we're going to calculate and so on.
1:25:13
And so till we come to Somyurek, which is close to the square root of the number, we're trying to find whatever this next thing happens to be.
1:25:23
So so this is a bad approximation. This is a better approximation, better and better, and eventually becomes a good approximation.
1:25:32
So one way to do this is as we coded it up on the slide here.
1:25:39
So we explained we had a helper function which started with the initial approximation zaibatsu and then went,
1:25:45
oh, well, let's go from that approximation to. The next one.
1:25:50
Using the magic formula, which is the iron plus one is expressed in terms of iron,
1:25:56
the next approximations defined in some previous approximation, and I derive that for you.
1:26:01
And we keep going again. So the helper function goes one, eight, two, three, four.
1:26:06
Eventually, we get to one of the areas where it says are this condition is now true.
1:26:11
Therefore, we stop because that means that the approximation is a good one. It's close to the square root of X, right?
1:26:15
So come back to the whiteboard. This is another way you.
1:26:22
This is nothing wrong with this and this is possibly the way you did. There is another way to express this, and that's to note that, well,
1:26:26
supposing I explicitly generated these approximations as a list, either I want to and so on and perhaps even an infinite list.
1:26:32
Yes, let's even do an infinite list.
1:26:44
So I'm not going to do is walk down that list until I find a way which is close to the square root of X, and then I stop and I just pop zero.
1:26:46
So how about this? I throw away all those.
1:26:54
And the lobby function for doing that, well, isn't that we just been looking at it so we got some function drop while and this has got to be specific,
1:27:00
you give me one of the approximations and I'll tell you what, it's a good or a bad one.
1:27:10
And if it's a bad one, I want to drop it. So there's something that says drop while bad or drop while no good, you know.
1:27:14
So there's a fun, she tells me, whether it's a bad one. Well, that's just the recoding of the function I just showed you.
1:27:21
This one, I guess this one is is highlighted here that tells me it's a good approximation.
1:27:26
So the inverse of that would be if it's not a good approximation.
1:27:31
So that and all I got to do then is to pull up what I'm left with is this infinite list over here headed by.
1:27:36
Okay, I'll just take the head of that list. Right. So incomes and X.
1:27:42
I divide it by two to get my Azera home, and I oh,
1:27:47
how do I go from zero to I want a two and so on is not alliterate because if I define a function next,
1:27:52
which will take you for one approximation to the next. Isn't that just Detroit.
1:27:59
Next. So can you see what I'm sort of starting to do?
1:28:03
I've got my initial X that comes in here. What is this thing that starts division by two?
1:28:11
Well, that's a section, isn't it?
1:28:16
So if what it was, whatever you give me, if I divide by two, I accept two and then I it's right now xed i it's right next,
1:28:18
given whatever that is in the next two weeks, I could do and then I, I drop.
1:28:28
Well bad. So this thing here is right next will give me this list, either I one to two up and I drop by about that gets about,
1:28:32
throws away the prefix that we which is full of rubbish and then I use the head function to pick off the the IC for me which is this thing here.
1:28:38
Out pops the answer so I can rewrite this as a sort of pipeline of compositional
1:28:47
pipeline which looks like a guess what it's like one hundred and thirteen.
1:28:51
M. See? So this is bad function is essentially the termination function I had on the previous version, except I inverted the inequality, I guess here.
1:29:01
So here's the X that comes in and the X is the thing I'm trying to find the square root of.
1:29:14
And what you see in the brackets is a composition.
1:29:19
There's the two that's composed with Detroit next that's composed of what is back and that's composed with head.
1:29:22
So one way I can express that what actually happens that that composition is given the X.
1:29:29
So that's exactly the same as if I have written these that come to the white board head of.
1:29:37
What was it drop while it dropped?
1:29:45
Well, drop ball is bad or whatever I call that function of right.
1:29:48
Next. Oh. Well, that's excessive, too, isn't it?
1:29:58
And that's true, that's floating point of. So that's exactly the same as the thing I've got above where I've got division by.
1:30:06
So what I've done is to take this out the out to the ex.
1:30:16
And here's the first thing I do the to think about this, you go right to the first thing I do with the ex is divided by two.
1:30:19
Glenn. The result of that gets given to Detroit next week.
1:30:25
It's right next to in this case, but I'm doing at the functional level now, so that gets given to it right next.
1:30:29
And then that gets given to drop while. This bad?
1:30:40
And then that gets given to head so that this thing works bit like a pipeline from right to left.
1:30:46
And sure enough, out here pops out approximately escrowed of X in.
1:30:54
So I guess what I'm saying there is that, you know, the F G of X is F G because, well, you can have as many functions as you want.
1:31:02
So after G of X is therefore by definition, h, f, g, if you can show this by breaking it down.
1:31:12
And therefore, f g h of X is that of an X, and I actually got dirty because as a for argument pipeline, so.
1:31:23
Very good, right? That's next week's topic.
1:31:38
So I think we'll have a little break, but this could be the end of the let's not let go.
1:31:44
But you possibly got lots of questions in. Your brains have probably exploded at this point.
1:31:47
This is kind of the hardest bit that you actually will be assessed on.
1:31:54
So and it will take a while for the up for some of you I know.
1:32:00
So right now, you should feel like those Meccans in that film, you know, these people this was a comic book,
1:32:07
but these people with enormous swollen heads, you know, your your brains are bursting out of your heads because this is the hardest bit.
1:32:12
So hopefully with the exercise we can do this week to play with them what we're going to be showing you next.
1:32:20
And then we'll finish up these things go on at you know, this is slowly sinking and you won't quite master it must be what most.
1:32:25
And that's OK, because you don't really need to master it for the assessment of this course. But it kind of gets you into that sort of person.
1:32:32
It can get you hooked on it. Gosh, you know what? What if they can do that? What else can it do?
1:32:40
And therein lies the sort of I guess I should give you a spade and you can start digging.
1:32:45
Right. I'll have a break because I need a glass of water to come back in. Let's say just come back at 22 and then if you want to leave, you can.
1:32:52
But if you've got questions like what the [INAUDIBLE] happens to me? Just the best you can give.
1:32:59
We got about ten minutes of questions before we start. So I'm going to break. OK, name of one.
1:33:03
It's a completely wonderful film called Mars Attacks, if you've never seen it,
1:37:15
so this is what happens to Martians when they try to type the composition operator and Haskell, it's a Tim Burton film.
1:37:21
It's completely wonderful. You never seen it should go right.
1:37:28
OK, three questions. Think I think you were the first happy one.
1:37:32
Yeah, I'm sorry, but could you please explain a little bit about what was the Etretat?
1:37:39
How does this rate stop? Yeah, well, it generates Mizzi, it generates the data here, so.
1:37:47
Say, I see it right. And. Let's do this one and let's do this.
1:37:59
I think it's you just give me an infinite list. OK, so so what actually happens is that Laterite a successor function of zero?
1:38:07
Well, this gives me. And what happens to that then this becomes zero zero comes down to the results of iterates,
1:38:17
the successor of now the zero now gets replaced with effervesce, which is the successor of zero.
1:38:29
And if you'll permit me to replace that with one. Because it is the same thing that I'll tell you what, let me just this might be quite instructive.
1:38:38
This actually is lazy evaluation so that it becomes the Sakib zero. Right.
1:38:47
So what's the rule for a straight. The room for it, right, is this one here.
1:38:51
So it's very effects as well. I'll put the the head of the resulting list and then recurse into the tile.
1:39:00
So if I come here. You can see our application to the table, the zeros come out of the the the leftmost element of the resulting list.
1:39:08
Now, the thing is. Oh. And why why does this list get printed at all?
1:39:16
If you look above, it has told you she has attempted to print every little book.
1:39:26
It's the GHC itself which is going to force the list in order that it can print it.
1:39:29
So it's the act of producing this list on the command line which forces the evaluation not only of the zero,
1:39:35
but that's already a normal form, but also this. So she's not great at this point.
1:39:42
I can compute, I can output a square bracket and the zero and the comma, because that's the shorthand for zero comes down to something.
1:39:47
In the order to print the rest of it, I need to force the evaluation of the tail of that list, which is literally zero.
1:39:56
Right. So what comes out next is, well, if I expand suck, so this becomes succoured zero and then that gets constant to iterate.
1:40:02
So I guess I should actually write this explicitly, should shouldn't say that zero.
1:40:15
That gets constant. And I put this in brackets, say iteration, iterate suck.
1:40:19
All right. So now this is why this is why doing it as a graph helps.
1:40:25
But essentially what you've got is the successor function over the now the recursive core.
1:40:30
Well, that's it. That that was my ex. I want the successor of X on the successor of the success of Zero.
1:40:35
But you got to remember that this of zero here is exactly the same as that stack of zero.
1:40:42
It is a graph, it would be clear. So GHC at this point says would be do having already produced the zero and says thought
1:40:49
oh I know now I can now the next number because the next number is the size of zero.
1:40:57
So it then computes and at that point to compute it's the successor of zero which is the one.
1:41:02
Which is what the one pops out.
1:41:07
And the remaining 11 it gets from iterates up, so, of course, by the time is completed, the one you got to remember that this thing above it.
1:41:10
Oh, I've just let me just this thing above it. Let me just copy that over.
1:41:19
So if I see his computer suck of zero and turn that into a one.
1:41:26
Then that is all. So now one, because it is the same.
1:41:32
This is this is the girlfriend actually sharing I was sharing on the documentary Rania's so of course,
1:41:36
that sarcastic and eventually going to come, too. Right.
1:41:40
So you can see how the list gets from zero one and then there's a two and then there's a three and so on.
1:41:43
So what GHC does is it just carries on. So if I ran away, we go again.
1:41:48
So it terminates in the example I showed you, I said something like, what is the take the first three elements of it.
1:41:54
Right. Of success or zero?
1:42:01
Well, that just because it's producing them one at a time. So what is the definition of take if you go back to take that?
1:42:05
I have it in the slides. No, I did. But it was it might be an.
1:42:12
Might be over here. Oh, yeah, so Take says, if any, is greater than zero, which it always is, no, so that is greater than zero.
1:42:18
So we chose three of them. So imagine microplane take to that iterates suck of zeroth outcomes, the one that we recurse the next time around.
1:42:30
Next time on research outcomes,
1:42:41
the two and then we recurse and next time outcomes the three and then one because and when we recurse the ending goes down to zero.
1:42:42
Yeah, so we no longer apply this rule.
1:42:49
So the the in this case, the list argument is this potentially infinite object sitting in space, so you touch me, I'm going to have an infinite list.
1:42:54
And at this point, I just I don't need to touch you because I now know this rule doesn't apply, that if I just return the end to this.
1:43:03
So all that comes out is the the zero. The one. The two.
1:43:08
And was it the three as well, I can remember what the expression was, and that gets comes down to the emptiness.
1:43:12
So it's the take function combined with the lazy evaluation, which causes the iteration to terminate.
1:43:17
Got it, yes, got it on, which means like even though the list is infinite and as long as we use,
1:43:24
take or take wire or job, while, yeah, it becomes not infinite list, we can count it.
1:43:33
Right. Well, the thing is the list is the list computes itself elements one.
1:43:41
Soon as it produces a cons it stops and says, OK, I've got a Kongs for you.
1:43:45
Let me know if you need the head of the table.
1:43:50
So that's so it's up to the consuming function as to whether or not it needs the head in the tail and if it needs the title.
1:43:52
I want to give you another relevant one at the time. At the time, at the time. And eventually the consumer function myself got enough.
1:43:58
Now, just like to take those here and it stops. OK, very, very good.
1:44:03
Thank you very much. You're welcome. Right.
1:44:11
Any other questions? Ryan.
1:44:15
Are you meeting right? You're not music. Know you're not music.
1:44:25
Can you hear me? I can't. I can't. Yeah.
1:44:30
Before you mention that, when we were doing conquering, we use fulled. Ah, because we want to save the complexity.
1:44:34
But why do you use fold. Well then like for other functions I want to use the same complexity like the add function or something.
1:44:40
No, no, because the there's there's an echo like.
1:44:53
Thank you. No, it won't, because that the thing about the concat is that.
1:45:01
I show you. I'll show you this one. So the question is, do I bracket that left or right?
1:45:10
So the way you remember this thing in here is there is a list, you know, it's some X one,
1:45:16
one up to one and some arbitrarily big number and one, you know, it could be a million.
1:45:21
So I don't I really only want to scan that list once. Not not many, many times.
1:45:27
So that's why we use the phone right now. In the case of something like plus I've got an X one plus the next two plus an x ray.
1:45:31
Yeah. So in that case, I've chosen to fold, but I want to fold left.
1:45:43
Sorry. So essentially I'm realising that as if I've done that zero plus X one.
1:45:46
Yeah, and then I've done that, too, so this is the way I've chosen to bracket the this one is this way.
1:45:52
I've chosen to bracket bracket it that way. Yeah.
1:45:57
So it doesn't matter with us, because these things are just numbers and it's it's associative, it's chemistry.
1:46:03
These are just numbers so that I haven't got the problem that the task of walking
1:46:09
through that list is is order of n order when one where this is the one in here,
1:46:13
because I got to walk the entire list before I can join onto this law, whereas here I don't have that problem.
1:46:18
It just is just the number. I've got to calculate all the exits anyway, and it doesn't matter what order I had them up.
1:46:24
Modulo floating point rounding errors and so together, whereas it does matter what order each of these lists,
1:46:35
because, you know, if I bracket it the other way, I keep traversing this list again and again and again and again.
1:46:42
So I'm I'm sort of traversing and I have an ever growing list.
1:46:50
It's completely the wrong way to do it. Marcel Marceau.
1:46:54
I think it might be that's not so in a school function, there was a question cocounsel in the left hand side.
1:47:05
Oh, I didn't forgot to ask you. I didn't know. Yeah. And I'm assuming we were cannot because of the Omid X on both sides.
1:47:15
And we don't know what next is. Yeah, it's not.
1:47:22
So we can't it would be lovely if we had to cancel the X here because it looks like they
1:47:26
have actually question because unfortunately the scope of this X is the whole function.
1:47:30
It so happens I'm using it inside the definition of next and indeed the definition of is bad.
1:47:35
So it would say I doubt it, but I don't know what the actual. OK, thank you.
1:47:41
OK, thank you for reminding me. Thank you. Is that an old hand or a new hand.
1:47:48
High tech is an old hand. Well, it is tend to and I do feel a Richard one quick one before we stop them.
1:47:58
So for this next and is not a function, it's impossible for us to sort of.
1:48:05
Change it to like the dot function format, like above.
1:48:12
Oh, well, yeah, so you can take any function and write it point free.
1:48:17
Good luck on that. You can yes, you can. Is it obvious what we do here?
1:48:27
We take the. It's not I can yeah, you can do it.
1:48:33
The thing is, the more complicated the expression, the more the harder you have to think about it in order to get the equipment out.
1:48:48
So, yes, the short answer is you can take any function point for it,
1:48:54
but it's usually a really bad idea because what you end up with is unfathomably complicated and somebody's looking at it.
1:48:57
I think what on earth is going on there? And after spending half an hour thinking, oh my goodness me, it's just a plus x ray with two or so.
1:49:02
So by all means have a go as an exercise, but I wouldn't lose sleep over it.
1:49:10
So there's a there's a website called Point Free.
1:49:16
You can go and have a look at it if you want to play with play in the space, which is quite good fun.
1:49:19
All right, so this should this should sink during the week, so I'm going to stop to give you a chance to get on the labs and ask questions and stuff.
1:49:29
So I. I have to get down at some point. I got on the meeting before, unfortunately, but I'll try and come afterwards to.
1:49:37
Thanks. Thanks. Thank you. Thank you.
1:49:47