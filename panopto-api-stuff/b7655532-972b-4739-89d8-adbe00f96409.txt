ID: b7655532-972b-4739-89d8-adbe00f96409
Title: Functions
Category: Haskell
Lecturer: Anthony Field
Date: 11/10/2021
All right away. OK, well, I'm going to start now.
0:07
So welcome back. So hopefully you've had a chance to play with some of the unassessed exercise I gave you to look at on Tuesday.
0:16
And looking at the timetable, we have a lab scheduled for tomorrow afternoon at two o'clock.
0:27
And I'm hoping that will there'll be a good number of undergraduate teaching assistants with.
0:35
I can hear you on the one glitch.
0:47
Look, somebody is meeting me and this I don't know if it's accidental, but please don't press the mute button.
0:53
This happened three times yesterday. All right, so I don't know quite how this has been configured by Oktay, this this wasn't possible last year,
0:59
but don't don't post please mute yourselves unless you're asking a question.
1:08
But don't meet me if somebody does accidentally. Can someone just shout to say that they can't hear me and I will mute myself?
1:12
So I don't know how much of that you got. But what I was saying was that we have a lapse session scheduled for tomorrow afternoon in the labs.
1:22
So if you can either join that remote play or you can come physically into the building and sit wherever you wish.
1:30
And what I was saying is that we should have plenty of undergraduate teaching assistants and duties there.
1:36
And I will try to find time to come down to the lab myself at some point to see you and see how are you getting on.
1:44
So in the lab tomorrow, you can work through the exercise sheet that I've given you, the six associate.
1:50
You can play with their own stuff. You can download some exercises from other sources and play with those.
2:00
Or you can work on the I think you might have been given a lab exercise to play with.
2:04
This week is a very simple one, just getting used to using the limbic system.
2:08
And there's a submission deadline, I think, on Friday, which Constantinos has either explained to you already or is just about to Kaypro.
2:11
You have a question. Yet do you know if the decision tomorrow is in person or is it still online?
2:18
As I said, I probably missed what I said.
2:27
You've made you can join this online or you can come into the building in person and you can find a seat and you can sit down.
2:30
OK, thank you. It's up to you. Yeah, that should be enough seats to accommodate most of you.
2:36
I anticipate that not all of you can or will want to come, but there should be plenty of seats for those of you who do.
2:41
So, Danny, you have a question about the unassessed exercises, even though it's not being graded or anything.
2:48
Would you still like us to submit it, OK? No, no, no, please don't do that.
2:56
This is entirely for you. Just just to gauge, just to help you, to learn to grill and to gauge how well you're doing.
3:00
There comes a point, you know, this week is really very basic introductory stuff.
3:08
I can tell you that it's going to get a bit trickier on Monday. So I doubt whether you're going to get too stuck on that one.
3:12
But I suspect you're going to get quite stuck on some of the later ones. And that's fine.
3:19
That's just part of the normal learning process. But you don't have to submit anything.
3:22
But what you can do is you can you can raise questions on edge.
3:26
You can talk to your in your in your tutorial groups. You can have a discussion about any of those exercises.
3:30
And particularly, actually, I would focus on putting a hand up and asking questions in the lab.
3:35
And the really nice thing about being in a lab is that you're surrounded by all these wonderful bright people just like you,
3:40
who may be virtually stuck on different parts. And if you put you put your hand up or ask the person sitting next to you, they may know the answer,
3:45
but you use the lab as a great opportunity to to pick other people's brain.
3:52
So a couple more quick ones. I did need to make a start.
3:56
Richard is a pressing question said this week on Gayed.
4:00
There's another leg scheduled coursework for Haskell sequences that I was talking about.
4:04
Yeah. So so we do we do we need to try hard to handle that or yes.
4:11
So the unassessed sheets you just take away and do them in your spare time and do as many as you can or wish to do.
4:17
But the the there is a weekly exercise due in on Fridays.
4:23
So the first one is a very simple one and you should submit submit something on Friday afternoon and I don't know what the deadline is,
4:26
but we'll find out soon enough. Andrew. Oh yeah.
4:34
I just want to ask my wife. I just go out out. But then I just want to ask, like, where did you submit this?
4:38
Just cake. Well, let me just have a think, because things have changed.
4:43
You need to need to have Constantinos giving you the lab lecture yet.
4:50
On stunned silence, I seem not so so Konstantinidis will give you detailed instructions on on the submission process, you don't just submit to Kate.
4:58
I've said things have changed, so I shall probably should leave it, Konstantinidis,
5:12
because there are some technical details he needs to tell you about, because I need to get on.
5:16
So what I'm doing. We have a break in a minute and I will just drop in one one just to see because I'm not actually sure what he's told you yet,
5:20
but information is giving you just another quick question. Like where do you work?
5:27
Like where are you supposed to find this exercise on Sacia?
5:31
Or it sounds to me like he hasn't given it to anybody actually come across the sequences exercise.
5:34
And was it given to you by constant Tinos or was it put on materials or what?
5:43
Does anybody want to share that or is it something that you haven't had yet? No, I haven't seen anything like that.
5:48
Or, you know, hang on a second. I'm just looking at. It is on page after this lecture.
5:52
It does look a like on your timetable at four o'clock.
6:01
You have a session with Constantinos. So I think all issues to do with the weekly exercises will be resolved by 4:00.
6:06
So let's leave it at that. OK, thank you. Yeah. Sorry, I should have I should have checked my timetable to know where you were.
6:12
My apologies. OK, is that an old hand, Richard? Yes, it is, I'm sorry.
6:17
OK, well, let's make a start. So you should be able to see the slide with functions on it.
6:24
But before I do that, I thought what we should do is just have a quick refresher on what you might have picked up from the unassessed sheet.
6:28
So I'm actually going to go to the GHC here. Just bear with me a second.
6:34
Just remember, one of my control keys is broken and.
6:39
I think that should oh, no, I'm in the long one, that's it. No. That'll do.
6:46
OK, so we're now talking so so so if you haven't already done so,
6:53
you should hopefully you've had a chance to to to get into GHC, which is what I've just done here.
6:56
And you'll probably see a prompt which are this is Prelude or Main.
7:02
The reason why says mine is because I've actually I've actually opened up a file with all of today's all if that's
7:05
got all of the examples from the slides that I pulled off into a Haskell script and I put it up on Scientia.
7:10
So in fact, if you go to scientia, you should find that there is a new file there called examples from slides.
7:16
So at any point at your leisure, you can download that it's a Haskell script and you can fire up GHC with that file and then it will give you
7:23
access to all the examples that you have seen up until now and that you will see in the lecture slides.
7:30
It's just to say, do you type in the morning again?
7:36
So I'm going to perhaps pull some of those up today and we'll play with them and tweak them a bit just as an exercise.
7:39
Right. OK, so I'm not going to ask you questions. I'm going to tell you things you should know.
7:44
So you know about the basic functions like plus multiplication, power and hopefully so, you know, eight percent gives me 50.
7:48
Now here's a great thing. So plus it's called an infix operator, right?
7:57
Because it appears between its two arguments, you should know how to turn in to a prefix function.
8:00
There's a magical piece of syntax, but if I do that,
8:05
suddenly that becomes a prefix of plus and I want you to use it as a prefix function in much the same way as I can use other prefix functions.
8:07
A prefix meaning the name of the function comes before the argument. And if it's got more than one argument, the function comes before the arguments.
8:14
You just pull about Left-to-right, essentially. All right.
8:21
So that's how you turn a prefix and infix function into a prefix function and infix operator to prefix function.
8:24
We tend to sort of use different words to mean the same thing sometimes.
8:30
So infix function, infix operator mean the same thing. Now the other way around you are familiar with the function mode mode 12 five I get two.
8:35
How do I turn a Prefect's function to an index function. Well that's what you do is you put these back quotes as either side of the name.
8:44
You're pretend that suddenly turns it as it's not that now looks to Haskell like an operator and it'll do the same thing.
8:52
So the other thing you were learning about was precedent's.
9:00
You should know that if I type eight plus nine plus plus nine again or something like that, you should know that's left associative.
9:02
So these operators have there's a type of floating around on Haskell dot org in the textbooks.
9:11
Do you take a look at and you can see the precedence and the associativity to these operators.
9:17
So plus has. Oh oh I forget what the number is.
9:22
It's got some precedent's which is slightly lower than multiplication, as you expect, and it's letters are additive, so it brackets it like that.
9:26
If I met the brackets is exactly the same, is exactly the same thing. So if I put the brackets can I get that well in.
9:32
He gives me the same answer to the same city. But actually it's as if I left the brackets out.
9:38
So you've got to be quite careful with operators like minus, you know, which way round is that bracket?
9:42
Is that the same as that? Oh no it isn't.
9:48
So therefore, that tells you something about the weight brackets.
9:52
So you can just by playing with the baby, didn't know these sensitivities by putting brackets at random. You can check that that's left associative.
9:55
So you should have come across a right associative operator. And what's the answer to that?
10:01
Is it too squared to the power three or is it two to the part two to the bathroom?
10:07
Well, again, in fact, in this case, you'll see that this is that way round.
10:12
And I guess if you've got something like six times four to five.
10:18
Well, how does that break? Well, actually, you'd expect pairing to somehow be more and have a high precedence,
10:23
the multiplication and indeed you can verify that I put in brackets and I'm going to get the same answer.
10:28
So so unlike addition, multiplication, subtraction, division and so on, which are left associative,
10:34
the powering operations, right associative, which is why in this case, that is the same as that.
10:40
OK, quick question, dummy. Yeah, what's the difference between left associative or right associative,
10:48
because I had some trouble counting exactly as I just said, if you put if you just type this expression in here.
10:54
Yeah. Can you see that? Yeah, if that were left associative, I would get the same.
11:01
My answer is if I put the brackets in there, but I don't get the same answer. OK, yeah.
11:08
So that means that they operate it.
11:14
So in other words, ghc, when it sees an expression with more Monoprice, it's got to work out implicitly where to put the brackets.
11:16
And this is all about where is where does ghc put the brackets.
11:23
It puts the brackets where it's told according to the associated beauty and precedence of the operator.
11:26
OK, yeah you should, there's things you know if you say five, six, seven it's a.
11:31
Oh, bear with me, so we came in this morning.
11:41
We came in this morning and discovered that we discovered that suddenly overnight JHC was printing messages in colour.
11:47
And it was rendering the rendering the messages in white on a white black background, which you can't see the error messages.
11:59
So I wonder if I can fix this. I'll tell you what, let me just live without the error messages for now and I'll fix it.
12:08
I'll have a half time and I'll try and fix it when we're going to break, because I could actually dismantle my home.
12:16
I think I'm going to dismantle my party section here. So I thought we'd fix this this morning.
12:22
The and it seems to have reappeared. So in between that, there's a bit of white space.
12:26
There is actually text in there. If I highlighted you just able to pick out the words.
12:30
All right. But don't worry so much. I'll try to tell you what the problem is.
12:38
Although they didn't tell you what they. So what is telling you here is that it doesn't work out where to put the brackets are ambiguous.
12:42
So please put the brackets in for me. And then and in fact, in that case, I it's hard to put brackets in to make sense of the expression.
12:47
But anyway, these are the sorts of things you would have come across in your unassessed sheet.
12:53
One of thing I wanted to talk about was conditional expressions.
12:57
So, you know, here's an expression of type some constants in just a just so it's a valid expression.
13:00
So we know that the two arms of a conditional must produce an object of the same type.
13:06
Right. So I can put a can put it.
13:12
If I put the number one on the left branch, then branch I've got to put a number on the right branch or something that evaluates the number.
13:14
So for now, I could do it nine times six and that's absolutely fine.
13:20
But you might think, well why is that. Why surely I could just say, well it depends.
13:27
You know, sometimes I want to give the number one and sometimes I want to give it a character. Well, actually, she actually will complain.
13:30
As you can see clearly, it's complaining that that is a type error.
13:36
OK, well, if I just highlighted just one more time, you're saying, oh, we can't find the right instance.
13:41
But anyway, basically saying there's a typo error, you can't have a condition to arms of non matching types.
13:46
So you think, well, let's just think about why is that? It's an expression, right? So it's an expression.
13:51
Surely I should be able to do anything with that expression.
13:56
I want to put it in brackets just to make sure that distinguish the condition from what else is going on.
13:58
I could do for mine is that. Yes, it doesn't matter.
14:03
It doesn't matter what the expression is, so long as the expression generates a number, I can subtracted from four.
14:07
In this particular example, you know, it wouldn't make sense if one of the arms let's change this up on the front of the arms generated a character,
14:13
you know, how on earth am I going to subtract the character from for all the boolean false from for you know, it doesn't make any sense.
14:21
So Haskell said, look, your programme is just broken.
14:28
I'm not even going to compile it, don't fix it, and then come back later when it's all we can buy one.
14:31
And once the programme once expression, once the programme type checks, then it will execute the programme for you.
14:36
Now if you if you've written Python programmes before and languages and programmes another what are called dynamically typed languages,
14:42
you know, it was perfectly, perfectly happy to accept programmes like this and actually fall over at runtime.
14:49
And I will try to argue very strongly that programming languages,
14:54
which Czech types statically at compile time actually refuse to run your programme, if it's broken, are actually not.
14:58
Is that to me is the way to go.
15:05
And there's a long running debate's been going on for about 30 years about whether dynamic or static typing is the right way to go.
15:06
I have an opinion and probably next year when you've seen enough about programming and programming language, you may have an opinion.
15:13
Your opinion may be different to mine. And if it is, you're wrong.
15:20
OK, so there we go. So that's why conditionals must have the same types on the arms and that guess this
15:25
will be a broken one because I've got a boolean on one and a number on the other.
15:31
So just finally, I also encourage you to think about asking the type of something, what's the type of true well, that's just a boolean.
15:35
What's the type of this character? Oh, it's such are you can actually also ask what is the type of a function?
15:43
So I can't actually write that. But if I turn because the functions have to be sort of in prefix, but if I just put the brackets running,
15:50
what's the type of plus and again here we see this little context thing.
15:56
And basically what it says is that plus is a function that will add two numbers are giving me a third number.
16:01
So rather than picking a particular type of number like into Floto double the Haskell type class
16:08
mechanism allows me to bundle up things that can be added together in these things called type clauses.
16:13
So when you say, no, don't worry about it yet, it's not going to get in the way. You come back to it at the end of the course and revisit it in depth.
16:19
It just says plus adds two numbers and gives me a third.
16:26
So I can take I also showed you sneakily how you can force the tiger if I like eight plus nine nine oh nine and I say, what's the type of that?
16:31
Well, it will say, well, yes, it's again, it's just a number, you know,
16:44
and the reason it's just a generic numbers because plus can add all sorts of different things together.
16:47
So I showed you how you can force or put it in brackets just to make it clear.
16:52
I can force that to have a specific type like in it.
16:56
And I can force this the number nine to have a specific type int.
17:01
Yeah. So I'm saying, well don't just take it now.
17:06
I mean I could, I could say double of floating this because I've just chosen it and it will happily add them together.
17:08
Now of course because I force the type of, the two are elements to be in it.
17:14
If I say I know it says ah that's an my own.
17:17
Thank you. That's an eight, it's not an arbitrary number.
17:25
OK, so you're not going to actually, I don't think there's probably no where in this course where you need to worry about forcing talks,
17:32
but when we come to see functions, functions, what we're going to do with functions,
17:40
we're going to we're going to give Haskell explicitly a type signature. So it's absolutely clear what the types of our functions are.
17:43
I can't think of any occasion where you're going to have to take a literal look like a console, like I can actually force this if I could pick one.
17:50
But I don't I don't see that apart from these little toy examples, just to just to show the type system, I don't think you need to worry about it.
17:55
OK, so there we are. That's then that's what you should have taken.
18:03
Oh yeah. I guess the thing is tuples chip was a very important things in them.
18:07
Let me just do a couple of examples of tuples so we know that we can form a Tupolev.
18:11
Two things of different types if we want like one and two is a perfectly valid tuple and you know that you can name tuples.
18:15
So perhaps if I say let p p pair on true in P, just give you about.
18:21
I told you sleekly what we're seeing more of this like that there are little functions for operating on Pascall first and second.
18:29
I don't want you to use them willy nilly. We'll come back to that next week, but you can do something like that.
18:35
And but the interesting thing you can do with these things is let me say, rather than watching something like that and just come back to this.
18:42
So this thing I'll just highlight this thing here is is a P-value.
18:49
Yeah. It's that only one cometrue. It's a pair. And this thing, does it just name the pair.
18:53
So whenever you see something equals something in Haskell, you're naming something or defining something here.
18:59
I'm defining and defining the whole pair. But here's the completely brilliant thing about Haskell is it's got this thing called pattern matching.
19:05
We're going to come back to this next week, but there's a sneak preview. It's an unnecessary one, I think so.
19:11
Actually, I can name the two components of perhaps the integer. I'll call N and the Boolean, I'll call Bing.
19:16
And that's a perfectly valid definition. What it does simultaneously is name the end to be one and the B to be true.
19:22
Think of it another way. What it's doing is matching this pattern, which is just a pair of variables with its value, which is a pair of values.
19:28
And the side effect of the matching is the out pops, the binding event one and the binding to be true.
19:37
So now if I wanted to, I could write something like B now given the true I could say N and that would give me the the one well
19:42
I could even perhaps say something because I can type anything in here as long as it's correctly typed.
19:50
I might say if b then and else zero I would get something like that.
19:55
So it just by playing and playing and playing and playing and all I wanted this works and try it out.
20:01
And if it doesn't try to understand why it doesn't that's, that's the way you learn the language.
20:07
OK,
20:11
so up really this week it's up until now we've just been treating the language or the GHC system as a little calculator so we can play these games.
20:12
Right. And I'm going to go back to today's lecture, which is about functions.
20:20
So you've been using GHC I as a calculator which has got all these predefined buttons on,
20:24
if you like, a plus and minus empowering and so on and so on and Clausen's.
20:30
But obviously when we write programmes you want to define our own functions, so how do we do it.
20:33
Right. So when we introduce a function we introduce its type, so we type something like this.
20:40
This is the syntax Proops this is the syntax we use.
20:46
With me, so, Syntex, were you so to define a function and we'll see how to actually say what the function does in just a minute.
20:50
The first thing you usually say, what type of object does it accept, which is what type of it return, which is the base and your wife concurrent.
20:58
Okay, so F is a function that takes A's and gives base.
21:07
So mathematically think about is the range and B is the, the, the,
21:10
the domain and the range is the range base that that is the domain and B is the range.
21:15
And there are other things you might be familiar with, code lines and so on.
21:20
If the function has got more than one argument, you just repeat.
21:26
So if this function G has got three arguments and returns a result, what are the types of three arguments with to see if the types of A,
21:28
B and C by Area C and if the results type is a D, the last Arab refer to the D, so G takes an eight and A B and C gives me a date.
21:34
All right. So we'll see some examples, we'll play with some of the show examples and the next slide to have functions with just a single argument.
21:46
So we're just going to look at functions which do this. And then in a minute, we'll see functio, the multiple organs, Husham cutting.
21:55
Functions are return multiple arguments and still be. Yeah, we'll come to that in a minute.
22:05
So in terms of returns, more than one thing, what's one way in which I can glue two things together or three things together over the tuple?
22:09
Yeah, the only way I can do it is a cheaper so here we would have to have a tuple type.
22:18
Then I can return as many things as I want, but wrapped up in a tuple. So the answer is they can only return one thing.
22:21
And if you want to return to things, you put the two things into one thing, you make one tuple and that defines the type of de.
22:27
All right, so let's just say so I'm not going to read through every line of the slides for you to read off line,
22:34
so I'm going to highlight on pile examples. So here, for example, is a success function functionality.
22:39
Look at the type signature. This is a really boring function you give me and I'll give you back and you can be one to give it to you.
22:44
Give me two or three. So that's the type signature.
22:50
And in this case, I just chosen a really simple type instrument. I could I could enrich the type with a context and make it an ambience.
22:55
I want I could make it a double. I'm just going to focus on a very simple example concretely, isn't it?
23:02
And give me back in it. What is the function to do so now?
23:08
To describe define what the function does. I write the name of the function as much as I would do mathematically in the mathematics textbook.
23:11
You just to remind you of the what I said yesterday, a maths textbook.
23:20
You might see you might see a function something like.
23:26
Yeah, and that would be a you'd understand that as being oh, that's a function which returns one to whatever it's given,
23:29
it returns one thing bigger and the same thing, but one bigger. So it's back to life in high school.
23:35
We just get the brackets. So, you know, we're going to write literally.
23:42
So it actually looks very much like mathematics. But just going to write that does the same thing.
23:46
You put the bracket and if you want, because there's no such thing as a single cheaper, we learn that also on Tuesday.
23:50
All right. So here we go. So that's so you can put the thing on one definition, on one line.
23:56
You can break the definition. What I advise people to do and you should have this discussion with your Yuta
24:00
is that I advise people to break the line at the end of the left hand side.
24:07
So this thing here is the left hand side and basically the left hand side is the function name in this case,
24:10
the simplest patent possible, which is just the Patnaik. So this says success that you give me.
24:15
Absolutely. Any X and I will return X plus one.
24:19
If you give me three, I'll give you four. And I like to break my lines at the end of the left hand side and put my equal sign on in the third column.
24:24
So in other words, this case under the C.
24:32
The reason I do that is because Left-Hand Side can become very long, we'll see some examples in the weeks to come.
24:34
And so it's always nice to know where the right hand side begins.
24:42
So it's the right side always begins in column three or column two column for where have you chosen to put it somewhere consistently.
24:44
Then I always know where to find your right hand side. So that's what I would advise you to do, and I will fairly consistently stick with that,
24:50
I'll break the rules sometimes when I'm just defending nested functions.
24:58
Welcome to the show example. But that's what I advise you to do.
25:01
Oh, by the way, there is a function called the successor function built into Haskell, which does exactly that.
25:05
But having defined that function, I think that's actually now preloaded.
25:12
So I've loaded the file you're looking at or looking like the examples in the slides you're looking at, and I can do the same thing.
25:16
So I've just basically reconstructed the success of function with a slightly more concrete type.
25:22
What's the type of the suck? What's the type of the built in function?
25:28
It's a slightly richer one because it's got these type. Plus it's better that it once I frozen the type of the successful function.
25:34
But you can do just just to reassure you, what's the talk of success and function that.
25:41
Oh yes. Just remind me to enter. So a simpler version of the ones built in I guess, Alex.
25:45
Can you hear me? I can. I just wanted to ask you out for a second, you know, how you were saying how you define the function.
25:54
We saying better to do it on the same land or the next line or I if I cut out.
26:02
So this is here. So what I was saying is that I think it's better to break the left, to break the definition at the end of the left hand side,
26:08
in other words, just after the ex and put the equals in column three.
26:15
OK, because then all your right hand sides will line up every single function you write,
26:19
the equal will be in the same place as I look down the script.
26:25
And one of the one of the key things you have to understand about writing good programmes is that someone
26:28
has to read your good programme and the worst thing you can do is make it difficult for them to read.
26:32
It's a good layout and using good names are absolutely essential parts of the process.
26:37
And that is the second line successor X part of the left hand side or the right hand side.
26:43
So this first line is the type signature because the type signature,
26:51
that's a separate beast that tells the that tells the system what you think the type of the function is, and it will check it for you, actually.
26:55
And then the definition begins here. That's the left hand side.
27:03
There's an equals and there's the right hand side of the left and right hand sides are separated by the equal.
27:07
OK, thank you. So, in fact, if you if you if you really want that, you should be pretty obvious.
27:12
But if I go to if I look at my successor function, so if I want, I can put them on the same line.
27:18
And that's absolutely fine. The trouble is that the left hand side, I don't know how long the left hand side is going to be,
27:27
so that if I got a scanned into column 72 to find the first character,
27:32
the right answer was if I put the icon that I think was always in the same place.
27:36
All right, so let's go back to see some more examples.
27:47
So take a look at the magnitude function that the idea here is that I'm going to calculate the magnitude of a vector represented as a pair of float's.
27:53
And so that's an old hand, is it? Yes, sorry.
28:01
OK, so this is going to take go back to to buy a pair of floats and it's going to generate the magnitude of that vector.
28:06
So you know how to do that. Just basic Pythagoras's, isn't it?
28:12
So it's the it's the length of the diagonal.
28:15
And if the vectors represented by an X Y pair and then we just calculate the square to the sum of the squares of the X in the Y Y.
28:18
So, so I could have chosen any sort of numeric type. In this case. I've chosen Floto Creatures and Doubles.
28:26
Probably I wouldn't have chosen names here necessarily.
28:31
I can't choose, in fact, because the square root function is it doesn't work on it and he works on fighting point numbers.
28:33
So Flexin will be born in these upper function.
28:39
Asks whether a character is upper or lower case. So the way to do that, you can use the order function I told you about on Tuesday,
28:44
but actually you can directly compare characters and GHC will use the old function for you.
28:52
It'll automatically use the old function to work out whether your character is bigger than
28:57
the alphabetical character Cappotelli or less than or equal to the character Capital Z.
29:01
If it lies within that interval, it must be an uppercase character. Ankit, you have a question.
29:06
Yes, with your success, the function is you have to define that beforehand.
29:14
Could you do that in like the prelude domain, as you saw a time away and you can type all these things line by line into the GHC project if you want?
29:17
Oh, in the preluded you say, so what I got here, let me just show you what I've got here.
29:27
So in my other I've got two windows open I'm using here.
29:32
So if I go to the other window, what I've got at the top,
29:36
this is this is the this is the function I've given you on materials on CNN so you can download this.
29:37
So this is a file with a whole bunch of function definitions in it, which happen to be the function detonations I pulled from the slides.
29:43
Yeah. So what I did and what I did underneath, I'll go back and I'll leave ghc I actually said, oh please, please fire up.
29:49
I'm giving it the following examples and if I do that then all, all of the, all the examples in that file and now visible to GFCI.
29:58
So that's why I was able to say what's the type of the oh if I can type correctly, what's the,
30:04
what's the type of the successive function we now know knows that because it's in that file Jack,
30:11
you could just type by the success of this one by one into the GHC prompted from.
30:17
The trouble is as soon as soon as I exit the eye or I open a file and go back to the I'm going to lose them all.
30:22
So you should really if you're defining functions, you know, unless it's for some little microscopic test, you should you should put them into a file.
30:28
That's where they belong. Zach, did you just ask me that question was.
30:35
Yeah, yeah, yeah, so I was wondering, when I was testing out yesterday, I noticed that the success of function also from floating point numbers,
30:41
which I found with most of my well, because I kind of gave you the answer.
30:52
If you look at where do you want to find out the answer to that question, just to ask what,
30:58
what, what, what he thinks the type of the success of this is the built in one here.
31:02
And you can say.
31:07
Yeah, I know, I know exactly, but I'm just wondering, why do they treat it to be like that doesn't make sense if they're actually using it,
31:09
because success is defined in one of the actions of theory.
31:18
It doesn't really make sense for you to have a success of a floating point number or an integer somewhere in the same way.
31:23
Why is it allow me to do the success of one point one? Well, yes, because it can.
31:31
I think, you know, when you because Haskell is a sort of is a very mathematical programming language,
31:37
it does try to stick to standard mathematical conventions.
31:43
And I don't think it always does doesn't always succeed in doing that. But where it can, it does.
31:47
And there's a very important branch of maths, a mathematical category theory, which leads to things like Monash's,
31:52
which will be studying later on in the course and elsewhere in the advanced programming. And in there in there you have things called bad laws.
31:57
And so those are preserved by Tasco plays a lot of them.
32:04
Takes a lot of attention to that and make sure that the monologue is to preserve the monologue from cutting,
32:10
etc., and there are many, many other examples. Thank you.
32:15
Yeah, so we could talk endlessly about this, but I think I need to move on.
32:18
OK. And so that's that's the what about the I showed this one yesterday.
32:23
Actually, this is this is a slightly simplified version of the Biltmore because it works tontines you'll see that the building is like Richard Time.
32:27
So, OK, well, we learnt on Tuesday that I could write this using this thing at the bottom if it's more typical zero than true or false.
32:35
But we now know that it is if P then true or false is just the same as P the don't write something like that because,
32:42
you know, then it is going to get to be minus 10000 marks. So to cut a long story short, rather than writing that, we write this instead.
32:51
Yeah. And it's much nicer that way. It means that you understand the concept, the booleans, you know,
33:01
even x the function that asks whether it is the same as the function, which asks whether the two equals zero.
33:05
Oh by the way, what's going on that I can see a hand come back to in just a minute.
33:12
What's happening there? If you think about binary numbers, if you know about binary numbers, you know,
33:16
the integers are represented by sequences of binary digits, something like this.
33:22
So if that's the one thing I can tell you about that number, I would probably not knowing how many bits I couldn't tell you what number represents one
33:29
day I can tell you for a fact this is an odd number because that last digit is a one.
33:35
And if I see a number that ends with a zero, I can tell you that that's an even number because it ends with a zero.
33:41
So if we had some clever way of pulling off that last digit.
33:48
Then I could use that to determine with the numbers, even A-Rod, and that's exactly what mod.
33:52
So if I say two and this is X, yeah, then that will pull off in that case, that will give me the one with this thing.
33:58
So by pulling off that last stage and asking whether it's a zero one, I can determine whether or not the is even,
34:07
which is why this function to which is why this function is defined to be the way it is.
34:12
Quick question. Hello.
34:19
Oh, yeah. So I tried to define our function and prelude and it just as variable, not in scope.
34:26
Is like, well, yeah, well, we don't go up in a minute, but when you've got a problem like that,
34:39
you're willing to raise it in the labs, because for me to tell you what's wrong with anybody.
34:46
So we need to see the programme because it depends a whole bunch of factors. What, what, what?
34:50
When it says it's not in scope, it says I don't know. What if you say we've had some X is X is not Inkscape.
34:54
I don't know what X is, what it means. X isn't defined anywhere. It can't see it, therefore doesn't know what to do with it.
34:59
You can see that people become if I say what's Y plus one is what it says is variable,
35:05
not in scope y if you can see that this because y isn't fun, because it does define one and then refer to it would be absolutely fine.
35:14
So if you, if it develops tomorrow, if you can't, if you can't fix it.
35:22
Come on ask. Good. All right, just give me one.
35:25
So those are all saying now those are singular. So when you say magnitude, you don't think of magnitude having two arguments in generating a third,
35:31
it's got one argument that one argument happens to be a right.
35:39
Just one quick aside, because I want to just introduce you to the comment syntax in Haskell.
35:45
So sometimes you want to put a comment in a programme to help the reader to understand your programme or to Richard.
35:50
Is that a quick question about the previous. Yes.
35:57
So I'm just going to ask about the first part of the function, because I tried to define the type of the function like a thing like that.
36:04
Of the. So the first magnitude flug float gives us and I think it can give me an error, I'm not sure like why that is.
36:15
Yeah, well, again, until we all say or programme, we can't we can't have a discussion.
36:25
So, again, raise it in the lab. One thing it might have happened, if you've got if you proceed with space D, A, capital M or something like that,
36:30
these these things must begin with A lowercase letters B that it could be that the spacing, the indentation is something I should have said actually.
36:39
You see the indentation I've got here excuse me. Indentation I've got here.
36:47
Yeah. Oh it's not. Allow me to do that. So I got two spaces of indentation.
36:51
To get to the equal sign on the second line, this definition here right now, if I put the equals under the M,
36:57
it doesn't know what it means, thinks it's the start of the next function definition. So it's interesting how schools lay out.
37:02
Sensitive the indentation matters.
37:08
So it uses it to parse the programme actually to work out what the programme, how it should interpret the programme,
37:12
and you should use the layout to make your programmes easy for other people to read the ones then perhaps.
37:17
So comments, so a comment just helps the reader to understand what I'm doing and and another another useful
37:26
use of comments is when you want to say to the user of one of the functions you've defined,
37:35
look, this function is only designed to work in these circumstances so that you give me
37:40
a value you can you give me a value that it's the function is designed to accept.
37:46
It'll be fine. It'll do what it says on the tin. If you give me something else, it won't. So it's a warning to the user,
37:51
do not call this function unless you're sure that the arguments or the arguments you give it satisfy some pretty static property.
37:56
So a little example of that is the log function. What is the log function if I draw it?
38:04
You know, it goes something like this doesn't work inside the log.
38:09
One is zero and it's just undefined over here.
38:14
So you can't have a log of negative number. So how so?
38:19
Well, perhaps we should do is to put an have an error message that's printed.
38:24
Should you call the log function, should you call log fashioned with a negative number.
38:28
Another way to to to alert the user. The function is to put a comment.
38:33
So this these two little dashes in here, this is this is a comment.
38:37
Oh, this is a comment and gesture doesn't process anything after comment is literally text.
38:41
You just decide what you can write in there.
38:47
So this thing here is a precondition says that this function as a precondition in order to use it must be better than zero.
38:48
If you give it zero, even negative number is not going to work. So that's like a warning, so it's a comment given the use of the function warning.
38:57
Now, what I could do when I haven't defined the function here because it's a bit involved as an exercise,
39:05
you might like to go away and think about how to do that.
39:11
So you might think that's the first thing I should do, is ask whether I could put a condition in there.
39:13
So if X is less than or equal to zero, then somehow throw an error message so that, you know, basically just crushes the programme perhaps.
39:18
Or perhaps it throws an exception that can be caught somewhere else, become more, much more of that later.
39:28
Like I say here, I haven't done that. I've just warned the programme through a.
39:33
So I can put comments anywhere, you'd be a little bit careful with comments if I go back to my my editors screen here and.
39:38
Well, so I can put a comment anywhere, so, you know, what would be a good mom might be a good comment.
39:47
The nice thing about has is a simple function like this, you don't really need to go into it at all.
39:54
You know, you could say something like the successor. Function like that, well, isn't it pretty obvious by looking at it, it's the successor function?
39:59
So I think he would probably not need that absolute do not go down here, please.
40:09
And right now, add one to X, because that's really not helping anybody.
40:14
It'll just take me ten minutes to type. I wanted to ask where is the expression actually made that much clearer using just three characters.
40:21
So don't, don't use and don't litter your programmes with comments and particularly don't put your comments there.
40:29
What I encourage people to do is if there really is something you need to tell us about the function,
40:35
because perhaps it uses an interesting algorithm or or there's a precondition or
40:39
something else that we need to alert the reader to put your comments up here.
40:42
And I tend to put them in a little block just to make them stand out a little bit. Use it sparingly and wisely.
40:47
OK, so we want. So once we define functions, of course we can, then we can we can switch to GHC, I presume,
40:57
and we will update the by the way, what I do here and you probably come across this already, but what about down there?
41:09
Bear with me, and that's why I'm OK and I want to stick with me,
41:24
so I'm just I just hit some key I didn't mean to do and it's just just getting out of bed with me.
41:34
I think we're back to where we were. What was I just telling you?
41:39
Oh, yes. Yes. I was just saying how you look. So what I do down here is you can load of fun.
41:46
You just you can get this. You can read like the. This one's good. This one's called, for example or.
41:50
Alcohol and alcohol and reload, yes, so I can count on load, for example, I think it was that's the follow you can download and play with yourself.
41:57
That will that will be once you've loaded it, if you can reload it.
42:05
So once you've loaded your fire with your function, definition's in it. My could just bear with me.
42:09
Something's happened here.
42:17
It's OK, I'm using just in case you're curious as to what I'm doing, I'm actually using shortcuts, single key shortcuts to get me between the windows.
42:22
And I think it actually just wants to run out. I managed to get it back the other way. That's right.
42:31
So we'll see if you can then use those functions on the SO because what is a successful 569?
42:35
It'll tell you that what's even 50 is false and you can put these two together.
42:41
So the reason you can put these two together is because they've got the right type.
42:44
Success of 19 gives me twenty, which is an eight and even expects an eight.
42:49
And therefore we can be so we can compose these two functions together.
42:54
We can take the result of a malfunction and feed it to the to the next.
42:57
But of course, if I type success will be for the car to be a typer.
43:01
Because why? Because B is not an end. And like my definition said, success has only taken.
43:05
So don't bother to give it a character because that would break. OK, so perhaps we'll do a break.
43:11
It's a two minute break. Grab a glass of water.
43:20
Come back in two minutes. Just turn the microphone off. OK, stretch your legs, did you?
43:26
That's a good thing to do in the windows, right?
44:53
So let's look at Gardy rules. Now, what I want to do is just to so here's here's a function called difference.
44:57
Let me go to the file that I'm playing with at the moment and let's see if we can find this function.
45:02
And we are.
45:09
So what this does is what he's trying to do here is to find the absolute difference between two numbers, two floating point numbers, X and Y.
45:12
And here you'll see it's using these things called guarded rules.
45:22
So before I printed the rules, another way to write this deal, I'll just comment this out.
45:25
You can you can comment programme blocks of code.
45:31
If I get the right key, comment things out, using the common block, using a curly brace and a hyphen,
45:35
or I could go to and I could comment each one out one by one using two hyphens.
45:43
So that's called comment and committed block.
45:49
So let me just like this let me just write this a different way just to show you, because we know one way I can write this function.
45:52
I use a conditional count. I can say the F X is greater than Y.
46:00
What I'm trying to do is get a positive, absolute magnitude. Absolutely matching the difference between between the two numbers.
46:04
So I could use a conditional. So if that's true and I want X Y, otherwise I won't win one six and there's nothing wrong with that.
46:11
That will work just fine. There's a single function definition.
46:19
The single left hand side, a single right hand side and the right hands on is an expression which does the right thing.
46:23
So it just turns out there's another way of doing that, which is arguably slightly more idiomatic.
46:29
Haskell is the sort of style that you should use in preference to that, which is to use these cards.
46:34
So a God is delighted with the preferred card is prefixed by this vertical bar here.
46:39
Then we have a condition and that condition is a predicate that it is a predicate.
46:45
It gives me true or false. If that is true, we then commit to the expression on the right hand side of the equals if the predicate is false.
46:50
We go on to the next, we have a we keep essentially moving down the script,
47:01
in this case down to the neck next to God, and we evaluate that predicament.
47:05
And if that is true, we return that and so on,
47:09
and we keep going down the patient top to bottom until we and if we don't actually run out of good odds and we still haven't found a match,
47:12
none of the girls is going to be true then, in fact, that it's an error.
47:21
So it'll give me a runtime error. Has people complain because I couldn't find a rule that matched.
47:25
Richard, quick question.
47:30
So functions you can always just put one line after the equals sign like that, the right hand side can just be one on one line.
47:32
That's what I what I said to you earlier was that it's a good idea to break your right hand side and put them down here.
47:39
Don't know where yet. Maybe here in this case.
47:46
And you can do that, but you just have to design a layout convention, which is a consistent and easy for the reader, the programme to understand.
47:49
So typically when we use, guards will scan across and we'll put an equal sign in there and typically will also try to align the equals up.
47:59
So if you've got more than one guard, we'll put these two equal signs, one about the other.
48:06
If there's another function down here which has got three guards and I make
48:10
sure that I line these things up just to make the programme easier to read. But if you wanted to, you can put that down here maybe.
48:13
And that's a perfectly valid programme, in fact, if you've got a really long guard sometimes,
48:23
in fact in practise we do this, but in this case, it's a really simple garden.
48:27
There's no need to. So I've chosen in this case to do to do that.
48:31
Oh, Tony. OK, OK, again, good question.
48:39
Yeah, I think you answered part of my question, but so I notice that, um, with your second one,
48:49
with your second function, you kind of have like three branches to, I guess, what would be an if statement.
48:58
So how does that kind of end up being coded? So what's the syntax of that kind of thing for?
49:03
If I wanted to write signal using an if statement. Yeah.
49:09
I'll show you that. So let me just finish the discussion first and then, Matthew, just a quick one related to something I've just done most.
49:14
You want to wait? Yeah. So could you quickly just remind you what this please.
49:20
Oh, God is just one of these things is so different by now rather than writing is using a conditional.
49:25
I've got two guards that's got no one. There's got no to the guards.
49:31
So the guards are expected top to bottom and we keep going until we find one.
49:35
That gives me true. OK, I think if we don't find one that gives me so otherwise here you can think of in,
49:40
in or in all other cases commit to this rule here to commit to this.
49:48
Right. And so here. Yeah.
49:52
So signable, for example, what a signal do this is this is this has got to minus one zero one depending upon the magnitude of the number I'm given.
49:55
So that's why there are three cases. So, God, no one says if it's less than zero, the answer is minus one God.
50:02
Number two, God. Number three, there's some these things are sometimes called Claus's.
50:07
You know, people can read names for these things,
50:12
but a guard is just it's just it's just think of it just a way of wrapping up a predicate to decide whether or not to pick that rule, AJ.
50:13
Magnitude function, you had X and Y as a triple in brackets for difference, you have it as you know, right?
50:26
Which one would you recommend? Is it just like, OK, that's a good question.
50:35
I actually meant to raise. So what I could do. Let's just play for a second.
50:38
And this is what you should do when you ask this.
50:42
Oh, well, perhaps I could redefine this differently so that instead of taking two numbers, it took a single pair of floating point numbers.
50:44
But now, if I tried to execute that, it's going to complain, isn't it? Because I haven't fixed my error message.
50:53
It's going to complain that would do it. You see, it will complain it's reloaded.
50:59
Well,
51:06
it's complaining about the fact there's something inconsistent here because the time signature says this function is going to accept a single pair.
51:06
And yet the rule says it's got two independent arguments, if you like, and they're not consistent.
51:14
So to fix it, I can simply turn that pattern into one that matches on a pair sort of standard textbook mathematical sense.
51:21
And that will be absolutely fine just to convince you of that at.
51:29
It's now consistent with the type signatures when I read it is OK and when I come to use it.
51:33
So if I want the difference between two numbers.
51:38
Well if I type that, that's the that's the old way. So what I have to do is package those up into into a tuple and then it's absolutely fine.
51:41
So it's the absolute magnitude. The difference if I give it one, for example, I get four.
51:49
But that's not the way it was defined to be, I guess, to to demonstrate the fact you can you can define the same function in different ways.
51:54
You can get ten different types that are sort of similar semantics that do kind
52:02
of the same same thing in one case have got to flow to a single pair of legs.
52:05
So so they are different because they've got different types that you should actually make that clear.
52:09
So let's go back is. All right. The question about signal.
52:15
So if I wanted to signal using a conditional I guess I'd say something like this.
52:21
I say, okay, well, let's first of all ask let's just get the whole definition up.
52:27
I could say, if any is less than zero. Then the answer is unequivocally minus one.
52:31
Now, if it's not, they're going to do another test nights in a good way.
52:37
What I also recommend you do is to pick a layout convention for your conditionals.
52:41
And this is the one. This is the one. And so I'm using an unfamiliar keyboard here and we use this much messing things up a little bit.
52:45
Right. So so what am I going to be in the US? I've only actually tested one of the three branches so far.
52:56
I just took another condition. And so I say L equals zero then.
53:01
The answer is, what is it, minus one, no n equals zero zero.
53:06
To see what I'm doing, otherwise, the answer is one, and that's a perfectly valid way of doing it,
53:14
you might say, well, I'm not very happy with that layout.
53:21
So you might have another convention says, I've got Nesto conditionals, maybe I'll do something like that.
53:24
So you have to pick a layout convention and stick with it so you can see how that why why having guards is actually really nice,
53:28
because all this guff with nested conditionals goes away. I don't have to write all that stuff.
53:35
I just write these three rules. And how can you possibly stare at these two and say the second one isn't isn't clear?
53:39
Those my guards are really nice. Guards are slightly more idiomatic way of doing testing in is.
53:46
Is that clear? Whoever asked the question. Yeah, there is a quick one.
53:51
Yes, I saw you wrote you write an are a few lines ago and I forgot what that was.
53:56
Oh, this is please. Once when I change the programme, um, and save it, I've got to reload it.
54:03
There are some that I could actually not do that I'd left it like this because I want you to see it,
54:11
but actually there are some quite clever ways I can get it automatically to reload. But then you wouldn't know what was going on.
54:15
So I'm just here. I'm just switching between two windows.
54:19
There's my editor when the and down here is my GHC butterfly button down here is magic actually windows.
54:23
So if I change the file, just have to reload. It is imported from the from the GHC window into it from the text editor to the window.
54:31
When I loaded up. I wrote that, so it's already loaded the fire, I'm just reloading and reloading, really?
54:41
Yeah, I see. Like you or I can do that so I can just go into GHC.
54:50
I'm not giving anything and I say, please load all I'm hitting the topic to do, then complain, but it gets me in the same place you choose.
54:54
OK, so I'm going to do all that because we don't like that nasty conditional but we do like.
55:03
Think let's put everything back as it was before. Yeah. OK, I was going to say that and then we'll go back to the notes, good.
55:12
So I think I probably said this, that this is one other thing you might like to think about.
55:25
So this is what happens. So when you look at a high school function, we'll see that there are often many rules that we'll see later.
55:29
We can even have multiple left hand sides and we just keep going top to bottom until we
55:36
find a rule that matches or regard them matches and then we commit to match the answer.
55:42
It's very simple. Now, if we have an otherwise, otherwise, I go back.
55:47
Otherwise, always. It's like it's like a ghetto, you know, if nothing else about his match, then return one.
55:53
But if I look at the wording on that slide, can you think how otherwise might be defined?
56:02
Jack, you were first. Finestra, otherwise, it's true what you think.
56:11
No, shut up. Yes, look, watch this.
56:18
If I write that it's exactly the same as the programme I started with.
56:22
Now, I know he doesn't quite look right, does it?
56:28
There's something slightly as if you've done some programming before,
56:31
you know that other languages easily in our Sabantuy, which is a bit like another one.
56:34
So there's kind of there's a sort of programers that bog standard 101 in the idiomatic way of saying in all other cases do this,
56:39
which is valse or otherwise. And so that's why they've chosen the key word otherwise.
56:47
But actually otherwise it's just fun in the high school probably to be true.
56:51
So when I when I first thought it was a few years ago, I was teaching this stuff and something was really quite intrigued by this.
56:55
So you go into the prelude, otherwise equally true, it's somewhere in there where it is.
57:04
And he said, well, could I choose any name other than otherwise?
57:08
And I said, well, yes. I said, what did you have in mind? He said, Banana. So you said, what?
57:12
Can I just go in here and say? Banana equals true. And then when I said I just want banana.
57:17
Yeah. Oh. I said, well, you can and the programme will obviously behave the same way,
57:23
but but if you showed that programme to a PTA, they're going to get the red pen out.
57:31
And I don't know how many minors, tens of thousands of moms you're going to get for writing that.
57:35
But clearly, you wouldn't like that because it's going to confuse the reader of your programme, but semantically is absolutely, completely fine.
57:39
This programme will behave exactly the same way as you pretend otherwise. Alex?
57:46
But just a quick question about what you did, the you know, how you defined the normal below the function, would that still compound normally?
57:52
Oh, yes, it does. That's a good question. I should have mentioned that you can write these functions in any order you wish as possible.
58:00
Doesn't care.
58:07
But what you must be careful about is if you write a sequence of guards, sometimes those guards have to be executed in a certain or another way.
58:07
In other words, top to bottom, because if you change the order, it can change the meaning of the programme.
58:16
So it is definition's themselves. Definition is going to come in any way you want.
58:20
Haskell just works out essentially what order to compile them. And that's what that's way we call.
58:23
Good question. Right. Let's get back to where we were.
58:31
OK, right just now, let's do some local definition.
58:37
I showed you let expressions. Yes, the Tuesday. Didn't you know that expression?
58:41
That something be something in something that's an expression you can put anywhere.
58:45
So if I come back to my. High school, high school, OK, did I do that?
58:50
Oh, dear. Hang on a second, what's happened?
58:57
They would make an awful lot about.
59:05
What on earth did? And.
59:17
Um, uh. I think I might have to I might have to shut this down for a minute somehow am I seem to have broken my somehow broken my nose is good,
59:24
I think, of the pragmatism. Let's go back to the slides of the debate.
59:44
I'll talk you through this. But I personally use the magic whiteboard instead,
59:48
and then we'll have a pause and I will try and fix it and maybe fix those error messages as well so you can see them.
59:51
OK, so I showed you that expression. So let's go back to this. You can do something like this.
59:58
Yeah. And this can be any expression you want.
1:00:06
It will just whatever whatever the value is, it gets named X and I can use the name X anywhere in there.
1:00:09
And as long as the types of Y, it'll just do what it isn't. So of course, this is just this is just an expression.
1:00:16
So of course I can do something like that and it's perfectly happy.
1:00:21
So you can put it anywhere. You can put an expression, you can put that expression any way you can, can put a conditional.
1:00:26
There are no restrictions.
1:00:31
Sometimes it's actually nice and slightly more idiomatic to use these things called workhorses, so workload's is a bit like let let expression,
1:00:35
except it's not you're not you're not aware cause is not expression of workload's is a set of definitions.
1:00:43
So I could say something here like let total distance be something, let distance concern be something in, let kilometres be to be something.
1:00:50
And then in general I could write my writing so and not be perfectly valid programme it just slightly
1:00:57
Torgeir more idiomatic to define all three definitions in one place and that's what happens in this work.
1:01:01
OK, so is that a quick question Alex, or is an old hand Marseille's God?
1:01:09
Yes, I have a question. So in the previous slides it says if we run out, of course we proceed to the next room.
1:01:15
Can there be more than one rule in the function? Yeah, that's right. We'll see that later.
1:01:22
We'll see that next week functions can have many rules and each rule can have many guards.
1:01:26
OK, and it says also that function must be partial. In that case, if we've got another one of the rules,
1:01:29
it means that I found an argument that doesn't match any of the rules and therefore the function is not defined on that argument.
1:01:35
That's called a partial function. Function is only defined on a subset part of its domain.
1:01:41
Is also. Oh, Richard, sorry, I beg your pardon.
1:01:47
So do you mind explaining the weird part again? Well, I'm just about to hang up here, so.
1:01:58
So this is a where clothes are where clause allows you to define multiple definitions in any order you wish.
1:02:04
And and the reason why the simple reason why we do this, the first reason is to make your programmes easier to understand.
1:02:10
So here is a function called Turns. And if you look at that function for long enough, you'll see, we'll think, well, what's going on?
1:02:16
And well, I'll tell you what, I'll show you what's going on. Then we'll come back and see another way to define it.
1:02:23
So if you come back to the magic whiteboard whiteboards, you stare at it, you know. Oh, I see.
1:02:28
There's some obviously there's some unit conversion going on with this kilometres. The metres on my start must be at this.
1:02:32
Oh, there's two sides for all. Must be a radius. Yeah.
1:02:39
So this has been quite nicely designed because I've chosen NHANES, which helps the reader understand what the programme, what the function is doing.
1:02:43
So mentally or otherwise, you might have a picture now, which is all I can see.
1:02:50
There's a road or something. There's a start point and there's an end point and there's a bicycle wheel or something.
1:02:54
And the bicycle's got away. It's just a number of turns of that bicycle to get from the start to the end.
1:03:04
Now, if I wrote the programme a different way, which I probably should pause after this and actually reboot the my team session,
1:03:09
yeah, I could choose different names for this. In fact, what would I do? Let's list on the magic whiteboard perhaps.
1:03:17
So I'm going to watch watching the magic wall. I know you can't see this because otherwise I'm just a writer in and out of flip mode.
1:03:23
So supposing I write instead that turns. And let's let's to some really bad names, by the way,
1:03:29
naming variables and naming functions in programming generally is that she really hard people think it's not really hard.
1:03:38
And it's one of the things you're going to learn this year is how to choose good names for
1:03:45
things and a classic mistake that that some students certainly make at the beginning.
1:03:50
And even one or two people still make the same mistake in the end is they think, oh, what names should I use in my arguments to my function?
1:03:55
I know I'll call them ABCDE PFG. Well, that's typically very unhelpful.
1:04:02
So another way to write this function might be to choose the names ABC and let me just write it down or flip modes.
1:04:08
So I guess this would be something like bear with me. So I'm actually going to write this function without all these helpful names.
1:04:14
And I think I'm trying to get this right, I guess that must be. And then I walked down to times part time.
1:04:22
See, I never thought that, so this function here.
1:04:34
Actually is the same function as one I've just shown you, but it's not very helpful, is it?
1:04:41
You can stare that for a while and you can sort of see what's going on. Oh, I see. Well, maybe so.
1:04:48
So then you think, oh, on what was it to policy. Do you think, oh, perhaps she is supposed to be a radius and you think, well hang on.
1:04:54
The reader might think, see that. Isn't that mean circumference. Anything we can't means.
1:05:02
So the reader, the readers already can be confused by the programme. But the names you've chosen by the chosen ABC.
1:05:06
So that's the first thing is naming is important.
1:05:12
The second thing is when you look at the definition on the right hand side, it starts with this one thousand.
1:05:16
You think, what on earth is this one thousand all about? Why they come?
1:05:22
Why are they multiplying this by next? Oh, I can see this is some with wheels turning.
1:05:26
Why the multiplied by a thousand.
1:05:30
And they almost have to infer the fact that some something's been given in nature and what's actually asked for kilometres or vice versa.
1:05:31
But it's really unclear if you go back and look at the programme, it's beautifully designed.
1:05:39
It it's actually over the top.
1:05:43
I mean, to be honest, perhaps I wouldn't write it out quite in quite such an elaborate way with such long names, but it is nonetheless a lot clearer.
1:05:46
So one good use of local definitions is to break a heart problem down in this case into three simpler problems,
1:05:52
to find the three simple problem and then piece together the solution using the three bits.
1:05:59
So just the act of naming them. Makes the programme easy to read.
1:06:04
Alex. I was just going to ask how it says you introduce definitions local to a rule,
1:06:09
does that mean these variables are not accessible outside of this function?
1:06:17
Yeah, exactly. Where could come to a scope in just a minute. This variable equidistance you can see here can only be seen inside the terms function.
1:06:20
Can't be seen anywhere else, it's only going to use inside the transformation itself.
1:06:29
Well, it's not the same for, though, is it? Yes, because in Aulet, if I say let X equal seven in the X can only be used in that box,
1:06:35
actually it can also be used in this box, but we'll come back to that when we do recursion.
1:06:50
They can't be seen in outside of that expression. That's important.
1:06:57
OK, now I have a break because I need to fix my team up session, so I'm going to turn things off for just a minute and then come back to you.
1:07:01
I might. To stop sharing, perhaps, as well.
1:07:09
OK, so as long I'll call you back in a minute. Too soon as I fixed it.
1:07:15
OK, I think we're back. We'll just double check the. Yeah.
1:09:53
OK, so. Can you hear me just double check some.
1:10:00
Thank you, carry on. So that's one use of where is to break things down, name them to help readability.
1:10:08
Here's another application of workflows. So here is a function called Normal's.
1:10:16
So let's see what's going on there. It takes a vector by the looks of it, it returns another vector.
1:10:22
And so if I come to the whiteboard, so I guess what's happening in here, his vector is the vector in X y.
1:10:27
It's a two dimensional Euclidian plane. There's Mike that I suspect to hear.
1:10:37
I guess what I want to know is the is the unit vector.
1:10:41
So I know there was another factor pointing in the same direction, but his magnitude is is one, so.
1:10:47
Well, we know how to do that. That's easy, isn't it? We we we simply normalise it.
1:10:54
So here's one way of normalising it. We take the exoplanets and we divide by the magnitude of the original vector,
1:10:59
which is buried for some of the two squares of the X and Y, and we do likewise with the Y.
1:11:05
But of course, if I do that, you notice there are two identical subtle expressions here and Kampala's pretty
1:11:09
much I don't know of any compiler that would actually attempt to spot this,
1:11:17
but you might think, well, why doesn't the compiler just do this once and remember the answer? They don't do this.
1:11:20
So you have to kind of help the compiler along.
1:11:24
And this is one way you can do is to define this common expression in a word, close, or you could use that expression.
1:11:27
Let me show you how to use workless. And as you define it, once you give it a name M m for magnitude, of course,
1:11:33
and then you divide, you use the M twice, once dividing the X in the second time dividing Y.
1:11:40
So this is the same function written in a slightly more efficient way.
1:11:44
It'll do half as much work actually when you only have to square it was.
1:11:48
All right. So what about a third application workload?
1:11:53
Well, I told you before the beginning that we can use pattern matching to decompose the components of a tuple.
1:11:57
Remember, I showed you something like this and I said, you can say let that's a slightly different example, like X Y equal.
1:12:05
And I have some expression here, which is a cheap I'll just give it a constant for the time being.
1:12:12
And now I've successfully named the two components, the tuples.
1:12:17
So so this is what you should think about whenever you see something equals something from now on and forever more,
1:12:20
you say what's actually happening there is pattern matching.
1:12:26
So the axis being pattern, the X Y has been pattern matched against the one three, so the X becomes the one in the Y becomes three.
1:12:29
So now here I can write something, an expression involving X and Y or in any combination or whatever, and it will pop the answer.
1:12:36
So this idea of using pattern matches quite handy when you're trying to break your problems down into simple, simple problems.
1:12:45
So here's an example, which is the idea here is I'm going to calculate the length of the horse race.
1:12:53
So we've been in horse racing in this country. And if you're not from this country, you're probably used to dealing with kilometres.
1:12:58
Well, one thing you'll learn about horse racing in this country, is it done using miles, furlongs and yards,
1:13:05
which are some ancient mechanism used by farmers basically to measure the size of a field or the size of a plot.
1:13:10
So you're going to get your neighbour to grow their vegetables on or something. So it turns out that it turns out sort of the magic whiteboard.
1:13:18
So if you don't know what a yard is, you do know what a metre is.
1:13:28
So this is a metre. That's one metre a yard is about that much.
1:13:31
So that's a yard. And of course, a yard is 36 inches.
1:13:40
I'm sure you know that well, what's a what's a furlong?
1:13:44
So it's the horse races are measured in miles, furlongs and then yards.
1:13:48
So it turns out that a furlong furlong, if you are wingy, is obviously 220 yards.
1:13:52
We use yards. Prediction on how many yards are there in a mile drive around the roads in this country?
1:14:02
You know, there's a thing called a mile. Well, obviously, that's one thousand seven hundred and sixty yards, isn't it?
1:14:11
Said obviously, and by the way, if you take 220 to 220 divide by 10, that could change, and that's the length of a cricket pitch.
1:14:17
So I was once told the cricket pitches are twenty two yards long because they
1:14:27
were played on a piece of land which was divided up into furlongs and the range,
1:14:31
the pitcher's mound is true or not, but it certainly holds water with me. So that's why that's why we keep it to yourself anyway.
1:14:36
So if I give you a race length as a whole number of yards, let's pick a number and let's clear this off.
1:14:43
Let's just do four, three, two, one to save us in too much thinking if if the race is four thousand three hundred and twenty one yards.
1:14:52
How many miles and furlongs and spaatz is that so you think, OK, well,
1:15:03
I'm just being told there's one thousand seven hundred and sixty yards in a mile.
1:15:07
So how many home hours do I get? I guess we're going to get to aren't we looking at that?
1:15:11
So if I break it up into a one mile to start to two miles, must be 110, 60 times to thirty five.
1:15:16
Twenty two miles. And if I was to track those two, I've got a difference of something.
1:15:28
Eight and five thousand eight hundred and one. So here's one more here, one seven sixty, here's another one seven sixty eight hundred one left.
1:15:37
So if I take the 800 one, how many furlongs is that? Well, if I divide that into two 20s, I get I'm going to get, aren't I, to twenty two.
1:15:48
Twenty twenty. On those three, and then this is the spare yards in here, so that must be 660 from eighty one, leaves me a hundred and forty one.
1:15:58
So the answer should be what I want to get back from this function is two miles.
1:16:10
Three furlongs on one hundred and forty one spur yards.
1:16:17
And how am I going to get this back? Well, somebody asked this question earlier, can I have a function?
1:16:22
Returns three things where you can't. You can't, you cannot function returns one thing, which is a three tuple.
1:16:26
So I just wrap this up in a tuple and those are the three numbers I want to get back.
1:16:30
So how does the programme work? Well, exactly as I described it, and the mystery is the pattern matching to to break things up.
1:16:36
So the first thing I've got here is a function well given given to integers.
1:16:43
Wouldn't it be handy if I had a function called, quote, RAM, which divided the first one by the second and then gave me the remainder?
1:16:48
So this is give me the question to the remainder.
1:16:54
So if I started with four, three, two, one, and divided by one thousand seven hundred and sixty, I'd expect to get two in here.
1:16:57
Because.
1:17:06
For each one divided by one seven sixty two in the division and the remainder therefore should be whatever I just said it was eight hundred and one.
1:17:07
Yeah. So that's a handy function that's defined in the prelude.
1:17:16
It's such a handy function. I'm going to use it twice here because I don't mean just number Miles.
1:17:21
I want the firms in the spare yards as well. So it goes as follows. Here's my race function.
1:17:26
You give me the integer number of yards and I will give you the integer number of miles Furlong's spaatz.
1:17:31
How do we solve the problem? First, I'm going to go into my work close.
1:17:38
I divide Y by one seven sixty. This will give you the number of miles and the numbers.
1:17:43
Bayard's thus far, in other words,
1:17:49
two and 801 in in my example and I'm using a pattern here to name those two things that come back from the quorum call.
1:17:51
So if you think what happens after that line of code has been.
1:18:02
Evaluated and will be in my example and will be to my primary be one.
1:18:06
So I'm just going to do this one more time. They're going to take the eight one, which is the white Pruyn here and.
1:18:12
Call again, this time with two twenty, that's the number of yards in a furlong and back will come the number of furlongs,
1:18:19
which in my example was more three and this may turn out to be a hundred and forty one.
1:18:25
So now with these two quorum calls, I've got four things in my hand.
1:18:32
I've got the miles, the Furlong's, the spare yards that's left over at the end.
1:18:35
And this intermediate thing, which I only need to do the the second second level capsular,
1:18:42
I can hear this intermediate furlong calculation and once I've used it, I don't need it again.
1:18:46
And what do I return? I return the triple MF wide.
1:18:51
Yeah, now just as a sanity check, that's a three item thing.
1:18:56
And those three things should be integers. And indeed, the type signature just confirms the fact that those three things are integers.
1:19:00
And how do I know they're only because they all come back Macall, to quote one mistake to introduce me back a pack.
1:19:07
So I'm living in the world of integers here, so I'm not convinced it works.
1:19:15
Should be all right now if I say, what's it called, race links. Oh.
1:19:21
They say four, three, two, one. Fingers crossed. Oh, baby, by Matthew.
1:19:29
So with the previous example, so there was the where a soldier.
1:19:37
Thank you. So there was the wear and then it. Not that one, sorry, at the bottom of the furlong.
1:19:43
Thank you. So with the where it says the first line of it would be comma y dash and then would it matter which order it's in?
1:19:48
Because with the with an example before the kilometres two metres was stated afterwards.
1:19:58
Yeah. Yeah. OK, let's do it. The answer is somebody else's words.
1:20:04
You don't know. You don't. We don't care what order they go in and out just to prove that to you, I'll put these in a different order.
1:20:08
And ask us to leave it to me and work it all out.
1:20:19
Don't worry. And actually the reason why excuse me, my kid, my kid, my other kids.
1:20:22
But we keep forgetting. So let's reload that. It's completely happy with it.
1:20:30
I'll get some answer. Yeah, and of the reason it has to do that way, we'll see next week when we start to look at recursion,
1:20:34
you'll discover that these definitions that may appear inside of work,
1:20:41
laws and certainly definitions, appearance in sort of programmes of a script file.
1:20:45
This can be neutrally recursive. They can mutually depend upon one another.
1:20:50
Therefore, you can't actually work out what all the derivative mean anyway. It's all to do with how they used.
1:20:53
So more of that next time is that clear?
1:21:01
So, yeah, I pick anybody when I kind of break in this way because people tend reprogrammes top to bottom, don't they?
1:21:04
So it doesn't do any harm here. To think that the first thing is going to happen is the the one seven sixty quote room and then the 220 Cribben.
1:21:11
Actually it may be that they are processed and put, you know, it doesn't matter because we get the same answer.
1:21:19
I just just as a tiny point here, I'm using a different, quote, room at the top of the programme.
1:21:26
If I didn't have done this because it's built in, but this is just an example.
1:21:33
If I decided I didn't want anybody else to see this function, it was only useful for this Raceland thing.
1:21:36
I could put the definition inside the function.
1:21:42
As part of the workload, I've just put a little gap here just to just to between this line and this line, I guess between that line,
1:21:45
that little gap in there, just to separate the definition on the undead and have done that is just just a lampposts.
1:21:53
But can you see now that the ground function is only visible inside the Reisler function?
1:22:00
So if I went back to GHC, I know it's defined in the public.
1:22:06
This is another function, I wouldn't then be able to type that function or use that function on the GHC prompt.
1:22:10
Because it doesn't know what it is, it's hidden, it's hidden inside the base,
1:22:17
like we say, only in scope inside sideways looks good now just a mark at the bottom.
1:22:20
You'll see me when we come to do some some serious programming probably later on in the term of impact, in preparation for your January test.
1:22:28
And before you look see me writing these local definitions without the type signature.
1:22:36
And amazingly, high school will work it out for you and in fact,
1:22:43
it will always work out the most general type of your finances will come back and study.
1:22:49
That's one of the top line.
1:22:53
But but anyway, what I want you to do is always difficult types of teachers in because it's at this stage in your understanding of the language,
1:22:54
it's good practise. So your Utya will expect you to type in, even though if you leave them out, GHC will work them out for you.
1:23:01
Look, um, so here's another example. Oh, so this is actually this is a slice of pie.
1:23:11
This is more of a remote. This is about types of names.
1:23:17
I'm just going to give another example. Let me just show you what the example is and then we can come back to the code and let's see.
1:23:21
I want them to. So I there's a there's a there's a maths problem in physics and computer called the energy problems.
1:23:28
You come across it. But look. So got my rotation, too, and I didn't need to do that.
1:23:38
It's called the anybody problem, and the idea is that you're given a collection of gravitational bodies like a galaxy or a solar system or something,
1:23:48
you can actually simulate how the planets mutually attract each other and start spinning around each other using the
1:23:55
force of gravity alone so that the building block of that is this little bit of code here which says you give me.
1:24:01
Two bodies, two masses plus or just one slightly bigger than the other.
1:24:09
And this has got some someone who's got some medicine, too, and I'll just do this in two dimensions.
1:24:14
But, of course, it would be typically done in three.
1:24:20
If this is a position X Y in my plane and this is a position X, X one, why don't we just start that again?
1:24:22
If this is I think I've called X one, Y one in a code and this is X to Y to.
1:24:34
What we what we need to do, the building block of the Iranian border problem is essentially to calculate gravitational force between those two bodies.
1:24:43
And what we do is for every repair, we work out the components of that force in each of the respective dimensions.
1:24:52
Here, there's only to. So if there's some force, if they are acting on those two bodies,
1:24:59
I want to know what the F resolves in the Y dimension and the F in the explanation and what is the force between them.
1:25:04
Do you remember the magic formula? The force which is acting along here is G and one and two upon R-squared where they all are.
1:25:12
Here is the distance between those two. And then what's the effect?
1:25:24
Well, that's just F times kerstetter. I think it was that angle and this is F some.
1:25:28
So what the program's doing is it's just working out what the effects from the FBI are.
1:25:40
So first of all, it calculates the R and then it works out the F and then it works out the Sun Theta and the coast.
1:25:48
They say, well, we know this time theta must be that distance here divided by R and cos theta must be that distance there divided by arc.
1:25:56
It saves me doing any trigonometric calculations. And what is that distance between here and here.
1:26:05
That's just the distance difference between the two. Oh, I've got a function to do that haven't we.
1:26:13
I call it difference and if that's if you go back to the code, I think I probably mentioned it at the time.
1:26:18
And in here I can use this ABS function,
1:26:25
which is built into the palliate is as an even nicer way of writing the different functions rather
1:26:29
than going through the rigmarole of having to define a conditional or a function with two guards.
1:26:33
I could actually just say difference x y is the absolute difference between.
1:26:38
The absolute value of X minus Y, so it doesnt matter what X and Y is positive or negative, it was going to be the positive result.
1:26:42
So back to my little example here. So hopefully that's sort of you can see this now.
1:26:51
So let's think about the type of this function.
1:26:56
It's taking an object which is like a let's say, a planet to the body.
1:27:01
I should call it a body minus five thousand miles when choosing a bad name.
1:27:08
It takes two bodies, one with the first mass in the position of the second.
1:27:13
And it's going to generate a force is a force. So a force is a pair.
1:27:17
It's a vector. It's a pair of floats, a pair of doubles or something.
1:27:22
So there's this thing in Haskell called a type signature, which enables me to name an existing type.
1:27:26
So here I'm saying a mass is exactly the same as if I've been float. And what I talk about force.
1:27:31
It's exactly as if I'd written float come a float,
1:27:36
the two dimensional vector of floating point numbers and similarly with a position and suddenly with the object.
1:27:39
What's an object? An object is a mass. I float with its position by its vector position of location in a two dimensional plane.
1:27:44
And the reason it's really nice to be able to do that is because it simplifies type signatures,
1:27:53
it makes them shorter and actually makes them easier to read.
1:27:58
So when I think about this force function, I would just take two bodies, two objects and works out the resultant force in each of the two dimensions.
1:28:01
Now, if I didn't have the time signatures, can you see how long this definition would be?
1:28:09
That would be mass position, that would be mass position and that would be a float kind of float.
1:28:14
And not only is that a very low on definition, it's not entirely clear what the best bits and pieces are,
1:28:20
which are named in the act of naming the makes the thing clearer.
1:28:25
It makes it easier to see what's going on. And all that's happening in here is I've just used to wear clothes.
1:28:30
I've broken down this really hard problem into it's bits and pieces.
1:28:34
There's the difference in the X direction is the difference of the locations and Y direction.
1:28:38
That's the attitude, the distance between them.
1:28:44
And this is the magnitude of the force.
1:28:48
I'm not putting those together to give me the X component of the force and the Y component of the force, and that's the answer.
1:28:51
This is beautiful, isn't it?
1:29:00
You take a nasty problem, you break it down into little bitty little bit is crystal clear and easily understood and beautifully named.
1:29:00
And then it's crystal clear how the bits and pieces get assembled to give me the final answer.
1:29:07
Joshua Halloo Yes, Chise with types.
1:29:12
And you said that Haskell was quite strict regarding types now has to always be type sensitive.
1:29:17
Does Haskell check on the type itself or would it just check its signature?
1:29:24
So for instance, if I was to create a function that took object as an input and output it mass position, would that error out?
1:29:28
I'm not quite sure. The question is, if you leave the time signature out, Heska will work out the type of the fourth punch.
1:29:42
They will give you a slightly more general talking to the one I've got here. But none of it will work it out if I give it a time signature.
1:29:48
What it does. It works it out anyway. And then just checks that what it's worked out.
1:29:54
What you've given is essentially a subtype of what it's worked out. That's the way to think about it.
1:29:58
Sorry. I mean, I guess what I'm trying to say is if if you define a variable to have a type of, say, object,
1:30:03
which that type be equivalent to mass position or the equivalent to a hospital has no way of distinguishing the difference between the two.
1:30:12
OK, if I, if I if I replace that with this object with mass position, then it's exactly the same type.
1:30:21
Yeah, so in other words, crucially, this is a very good question. I'm not in producing a new type, I'm naming an existing type just for convenience.
1:30:29
It's a good point. Later on, you might think, well, can I define Newtok?
1:30:39
Yes, absolutely. You can be studying in a couple of weeks time. Got it right.
1:30:42
Let's move on. So just to talk about scope, I think I'll probably give you an offence on scope.
1:30:49
I was going to say so I here the rules. So the scope of this intifada is that part of the programme where has a meaning.
1:30:54
So if something isn't in scope, you can't use it and Haskell will play it.
1:31:00
So all functions, all things defined or constants functions.
1:31:04
But I think to find the topmost level, if you like, in column one of my script, all those are global and there is scope everywhere.
1:31:07
So here's for example, if I look at my script here, Raceland is at the top most level, programmers at the top almost level in this example.
1:31:15
So all these things are global and therefore they can be seen everywhere,
1:31:22
which is why when I come to GHC, I can say what's what, what, what, what is that?
1:31:25
Well, it knows what baseline it is because it's in scope. So.
1:31:30
So the only issue is what about things like function arguments?
1:31:37
What about things like. Definitions in where clauses or let expression.
1:31:43
What are the scopes of those, so there's a relatively simple rule.
1:31:49
You just have to remember it.
1:31:53
Is that if I look at a function definition, but let's look at an example, so here's his a multi-function, if you like, this is a terrible function.
1:31:56
Don't ever write. This function is only just the book.
1:32:04
So here's a function which introduces two arguments, a function of two arguments, X and what I think, OK, what's the scope of X and Y?
1:32:07
We know the scope of F, the scope of F is everywhere.
1:32:14
What's the scope of that, some more so the rule is the X and Y are in scope only within the body of the function.
1:32:17
What I'm going to do, actually,
1:32:23
is I'm going to come to the whiteboard and I'm just going to copy this function out and I'm going to draw some pictures.
1:32:24
I'm just as I speak, I'm just copying it. I'll draw some boxes for you.
1:32:30
So the scope of X and Y is basically everything. After the equals.
1:32:34
Now, what have we got after the.
1:32:41
We got another expression over there with Workload's Point so that now in the world you see there's a definition of why.
1:32:42
And you might not think, well, what's the scope of that, why? Because now there are two.
1:32:49
Why the first why is the second argument that. And the boy in the work clothes is what is the why in the world?
1:32:53
So what's the scope of that? Why it turns out that the scope is the same.
1:33:02
So there's a conflict here. And then once you got a conflict like that, Haskell has to make a decision.
1:33:07
Which one is it going to pick? So the idea is.
1:33:13
So probably for very good reason, it picks the innermost one. So what that means is as there's the same function, well, what's the scope of X and Y?
1:33:18
It's this budgerigars box, which is the whole of the right hand side to perform function definition.
1:33:28
I'll put a little arrow that's the go to that box to find anything, anything inside that box, I can refer to the.
1:33:35
So in principle, everything inside that book, because I can also see the war everywhere inside the box.
1:33:41
I can see the way the problem is this little one here. Is also in scope.
1:33:46
Inside the same box, so we have to make a decision, the decision is we pick the innermost one and unfortunately,
1:33:52
what that means for the outermost one is it cannot be seen.
1:33:59
So this poor little fellow here is in scope. It cannot be seen it's invisible to the whole wide world.
1:34:04
Which is why you never want to come on this. What about this ex?
1:34:14
Look at this here. Well, let's just carry on, so what have I said?
1:34:19
Oh, I mean, here's a definition Y equals X squared inside the where clause.
1:34:24
What's the scope of this?
1:34:28
This. What's this? What we know what the scope of the War II is it many sentences.
1:34:33
But what about this X here? Well, that is the question I'm coming to is when I see this X in here.
1:34:37
Which is it, and when I see this in here. Which is it so this low X is in scope.
1:34:51
Everywhere here, again, because I just picked the equals on it, everything on the right hand side of the equals defines the scope of this.
1:35:01
So, in fact, about this model convention, that's the box where this Interex is defined by its scope.
1:35:08
So now you think, well, let's see what the programme means. So if I can just raise a few of these are a little bit confusing.
1:35:15
OK, so now, then. Which X what which X is this one?
1:35:26
So what we do is you just look outwards and find the nearest box.
1:35:33
So when you look outwards in any direction. I hope when I come to the edge of this box and I look around.
1:35:37
Oh, it must be that. So this is the same as that one.
1:35:43
What about this, why?
1:35:48
Well, again, he said we just look out in any direction when we cross this box and his head, which which way is inscribed inside that box?
1:35:50
Well, we know it's not this one because that's not going to go anywhere, but it is this one.
1:35:57
So that. Why is that one? So now we've got to work out is what is this X?
1:36:02
What do we do, what we just move out in any direction we like? Oh, I see.
1:36:09
That's the boss. X is inside that scope box, so which is it?
1:36:15
Well, again, we choose the innermost definition, not the ultimate one.
1:36:20
So that X must be this one. Even though this is in scope inside the hold of that box and therefore inside the whole of that box.
1:36:23
This definition, if you like, gets superseded by. Sort of following here.
1:36:34
So the Interex. That one, there is three.
1:36:41
So it is about why is three squared, which is nine and is if I said X, Y is X plus nine, I guess is that one.
1:36:45
In fact, there it is.
1:36:54
So why would you ever write a function which throws away one of its arguments, it turns out she thinks you do kind of do this all the time.
1:36:58
It's on the study are the functions or examples,
1:37:04
but certainly as a as a as a this function arguably can only serve to confuse people because it's got conflicting
1:37:09
scopes and it's got the same barrel being used twice in the same scope and same as the scope and so on.
1:37:16
So this programme is a bit of a mess, just to illustrate the point.
1:37:22
But is that clear? What's gardening's set out to describe the audience?
1:37:26
The function functions everywhere and the definition, unless the superseded by local definition, i.e. something inside of Workload's jingshan.
1:37:32
You have a question. Yes, so I have a question about so wait,
1:37:39
since we already have Latin extraction while we also have where so are they basically all the same thing except one foot and then on to the other end?
1:37:45
Is there any difference between them except this?
1:37:57
So the key to the key point is that. I come back to me.
1:38:03
But the key point is that Aulet expression is an expression so I can write something and you'll find situations where you want to do this.
1:38:07
I say something like equals seven, you know, an X minus four or something like that.
1:38:17
But that's an expression looking for that expression. Absolutely. Anywhere I want to programme anywhere, anywhere that's expecting an expression.
1:38:22
I can't do that with the workless, so I can't say so. For example, if I write if I wrote four times that plus one, I can't write for four times.
1:38:28
And X minus four, where X equals seven plus one, and that's wrong because that's not where clauses and where clauses are not expressions,
1:38:39
preselect expressions or expressions that work only a pair words in the function that function.
1:38:51
Very good. Exactly.
1:38:58
Richard said, I did understand a bit about the very close group, that example that you're showing right now, but would you mind going over it again?
1:39:02
I lost your bet with the. Well, a soldier on the screen is up to the whiteboard, so we got a function of two arguments.
1:39:10
Well, actually, let's start with the first. The big question is, what is this function going to do?
1:39:19
It's going to add X to Y. So your first thought is what works and what Y. So the answer is this.
1:39:24
X means that X. All right, the what is the why the why you might think we'll refer to that, it's just the second argument.
1:39:30
But no, it isn't, because down here there's another definition which has the same scope as the original as the argument.
1:39:42
Why rather this parable here in this parable here have the same scope and there's a conflict.
1:39:48
So you have to make a decision.
1:39:53
Do I mean the second the function or do I mean X squared where X equals three, i.e. nine and the rule is it means nine.
1:39:54
So given there's a conflict, you always pick the innermost definition, the one inside the where clause, if you like.
1:40:04
So this poor little fellow here never gets sick. So this function is exactly if you see the fine.
1:40:09
If I rewrote the function minimally, I write half of X, Y equals X plus nine.
1:40:14
And you should see it's the same thing now in practise,
1:40:20
you're not going to have this problem with trying to resolve this because you're not going
1:40:24
to be reusing the same name in a workload's as you've just used in your argument set.
1:40:28
It would just be it's just bad practises that are not doing. This is an example of a good programme I'm doing.
1:40:33
It will strike scope and scope resolution.
1:40:38
So the X in the second set, but the X in the second definition of Y is actually three.
1:40:43
That's correct. Correct. That's correct. Because I could take this one.
1:40:49
Or this one. And I picked the innermost one as well as everybody down Chye is a quick one.
1:40:54
I was just going to say that the X in the other one, she is like a different scope with the X you receive.
1:41:04
It's all right. Yes, except that, uh.
1:41:11
Justin. If I called this if I called this K, for example, K equals three, then this X would indeed be that one.
1:41:18
Oh yeah. Yeah. So since you are using the same name, the problem is I'm using the same name.
1:41:29
Yeah, I'm asking for trouble.
1:41:35
So that explains why you said that is the first argument for the function that the X in the first argument is to be used for X plus.
1:41:37
Why, but why not the innermost equality for that one.
1:41:45
Because this is not this is only in scope, it's on the right hand side of this definition here, that is.
1:41:49
Let me bring up and that is the scope of the innermost X.
1:41:58
So it's not in scope when I say F of X, Y was explains why that little X up there can only refer to the first argument to Y,
1:42:03
because the second one isn't in scope that.
1:42:10
So you will if we like to layer off where we have only excised the first layer of wear, but now the second layer, that's in a nutshell,
1:42:15
the executioner at the bottom can only be seen in the definition of why it cannot be seen outside it, which is exactly what you'd expect.
1:42:28
We do think it's quick. The courtroom example we just looked at. So the X equals three is only being defined to help me define the innermost Y.
1:42:35
And the why in this case is being defined to help me to find to compute X plus Y.
1:42:46
I think we need to move on this about things, but I think you just go away and you get used to it and you don't think about it anymore.
1:42:53
It is the other burning questions, Richard. You've got your hand up.
1:42:59
Is that a burning question?
1:43:03
I was wondering because I tried to use the expression to compute a like a function and really work because I was wondering if you can actually use it.
1:43:05
I can be rather using that expression. Yes, I can, perhaps I need to move on.
1:43:15
It's probably best if you if we have a concrete example like that when we just look at the code you've got and we can work on it together.
1:43:19
How about that? Because you've got to let it stop.
1:43:24
OK, let's just finish up talk evaluation, because this is this is kind of crucial to where we're heading.
1:43:28
So I'm going to let you read the notes in your spare time, but I'll give you the highlights.
1:43:35
So I mentioned the other day that the evaluation, Haskell,
1:43:40
is all about taking a computable expression and collapsing it into a normal form, something that can't be simplified anymore.
1:43:43
So what do I mean by that? If I got three plus four?
1:43:51
That is that is a computable expression, is not a normal form, but if I compute the answer, it is a normal form.
1:43:55
So you can see evaluations, a process of taking computable things and turning into new forms.
1:44:01
And there could be several normal forms. So if I've got so this could be said several computable expressions or some expressions,
1:44:06
so I could have something like deflective for two and that gives me five.
1:44:12
So, OK, well, there's quite a few things I can I can add the three to the four.
1:44:19
I can divide the four by two and then I can subtract one from the other and that would be the all things would happen.
1:44:22
Does it do the three plus four first or do they do that for two first?
1:44:28
The answer is it doesn't matter because it's mathematical. I can do it anywhere I want to go to get the same answer.
1:44:33
It's the first thing to understand about it, so I come back to my slides,
1:44:41
so if elevation is all about finding producible, especially the cool Rydex is,
1:44:45
by the way,
1:44:50
things that can be simplified like the plus in the death colour and then simplifying them and then simplifying again and keep them simplifying.
1:44:51
So there's nothing we can do. So I'll come back to the questions in just a second.
1:45:00
Are those old hands, by the way, if you call Richard Jingjing and if you could just take your hands down, otherwise, I'll come back to you.
1:45:03
So supposing I've got a function called double and this function, I could say double execute object.
1:45:11
Yes, of course I could. But I particularly wanted to show an example with excipients twice.
1:45:19
So double X is X plus X exactly zero and two times X.
1:45:24
Now then supposing I give you the probably double three plus four, how am I going to do it or how is Haskell, how could Haskell do it.
1:45:28
What it could do is first of all evaluate the three plus four which would give
1:45:35
me seven and then he could invoke the rule for double and what is double extra.
1:45:41
Double X says OS X plus X, which gives me in this case seven possible and and simple.
1:45:45
Seven is 14. And that's the normal form and out pops the answer. But I could do it low.
1:45:50
I couldn't lie because I could instead say start with rule double Xs,
1:45:55
X plus X and say you give me absolutely any old X and I'll give you back X plus X with X happens to be three plus four.
1:45:59
That means three plus four plus three plus four.
1:46:05
And you think, well that's daft isn't it, because I have duplicates in computation but it's mathematically perfectly fine.
1:46:09
Does it compute the same answer? Of course it does, because three plus four means the same everywhere.
1:46:15
Even on Mars passports seven does matter where or when you evaluate it, you get the same answer.
1:46:21
It doesn't it does matter. You evaluate it twice or once. And remember, the answer is always going to give you seven.
1:46:26
OK, so this is the other way. And unsurprisingly, it gives me forty. So which way does Haskell chew it essentially chooses this.
1:46:32
Not this this this strategy here is called Coleby value, but it says, given a function application to an argument,
1:46:42
you compute the value of the argument and then you apply the function.
1:46:49
So this is called call by name, uh, yeah, they will call it by name, so we'll call by name says no, no, no.
1:46:52
First of all, you use the function definition to ban the expression you started with and then then you push the computation inside, inside the result.
1:47:00
So you might think, well, that's death. And it's also really inefficient because that means the trip is focussed on twice.
1:47:13
No, it doesn't come to the virtual whiteboard. I'll show you.
1:47:18
So here's an expression, three plus four.
1:47:23
Written as a stretch, as a series of characters in a line, and if you know what I'm explaining, called by name,
1:47:26
the only way I can do it is to do what's called string reduction, which is to do three plus four plus three plus four.
1:47:33
Actually, what happens is this Haskell does not represent it as a string three plus four.
1:47:39
It represents is a graph. So it actually does this. That's what's stored in the memory of your computer, and just just as a slight aside,
1:47:43
it's important to understand how this might work if I've got something like six minus two plus one, how is that stored in the graph?
1:47:53
We think? Well, what I've got to do is just think about the brackets.
1:48:02
So, oh, the president tells me that these brackets like that and therefore the graph that looks like this.
1:48:07
Not the other way up. So given any expression, in fact, given any programme, you can represent the A graph, that's what a compiler does.
1:48:14
It first takes your programme constructs a graph from an automatic pilot.
1:48:22
Now, what about my double function? My double function says that double.
1:48:27
Is it double X, is X, plus X and what's going to happen if I say double three plus four?
1:48:32
Well, okay, just think about double X for the time. For the time being, you know, I can say so I can draw that as a graph as well.
1:48:41
So if you me, I can do this, I can say plus X X.
1:48:46
Yeah. Actually that's not what happens.
1:48:51
What actually happens just to raise the bar in the middle.
1:48:56
What actually happens is this is I get plus.
1:49:02
Of wait for it, wait for it that. So in other words, there's a single act which is referred to from both arms, both arguments of the two plus.
1:49:07
So now what that means is a point given double X plus three plus four.
1:49:21
What happens that that gets replaced by and plus of whoa, wait,
1:49:29
four plus three for the three in the four different, so therefore they must have different arms and that.
1:49:34
Can you see what's going to happen, you say. Right. Is that a normal form? No, because it's because Rydex in it.
1:49:40
OK, let's go and evaluate redacts. So Plus's plus probably in fact he does do this, it goes left side first.
1:49:46
So it comes down here first and says, well I can't tell you the answer until I know the value of that argument.
1:49:52
What is the body that's all human so. Well, let's find out what is three plus four.
1:49:56
So this gets replaced with. But that's the same I'm not sure that's Coppelia, that's exactly the same thing, this thing is still here.
1:50:01
But can you see now that. This reduction here is one in here gets replaced by seven because of the fact I visited it by going down this up,
1:50:11
so then it says, okay, thank you, that's a normal for now. All I need to know is the value of my second argument and then I can add the two together.
1:50:21
So now it comes down this one and it says, well,
1:50:28
I'm seven and it actually doesn't really know or care about the fact that it's the the it was originally the same plus three for the computer.
1:50:31
The so it just says seven. So it says, oh OK, so I've got seven plus seven and the answer is 14.
1:50:39
So in other words, this strategy of evaluating using a graph.
1:50:45
Gives you a call by name without the redundancy, and that is what Haskell does,
1:50:51
Haskell has an evaluation strategy called lazy evaluation, which is precisely call by name with sharing.
1:50:56
Oh, there's some other bells and whistles, but that's essentially the way to think about it.
1:51:04
So you get to make it so let's say about the last I want to let you go is think what's the implication of Corbi name?
1:51:09
Here is a function. Just look at this, what it takes to floats to float away.
1:51:18
So therefore, the pattern on the left goes something along the F of X,
1:51:23
Y and X Y A perfectly good names because they are just arbitrary floats, which says it X is less than zero percent, zero five.
1:51:26
Otherwise we return Y. OK, that's a great function. I'm sure someone can find a use for that function.
1:51:35
And let's give it some examples. F a three five.
1:51:40
Well I see. So X the three here, not less than zero.
1:51:46
Therefore we hit the otherwise the banana case and we return y which is five.
1:51:50
So three five is five. What happens if I give it F three and something undefined.
1:51:55
Like Infiniti. So what happens now, it's it says, well, the three is not less than zero, so it's not this rule that matches, it's this rule again.
1:52:04
And the answer is why? What was why? Why is there a maximum infinity?
1:52:15
And in fact. There's a thing I'll tell you about now is a thing called undefined in Haskell.
1:52:21
You might say, what's the type of undefined? Undefined is oh oh, so every type has an undefined element.
1:52:29
Oh, okay, so that means I've got an undefined bowland, undefined int and undefined char could be handy.
1:52:41
So if I go to this function,
1:52:46
what do I call this function in my script and just like call F I think I got like the name I was looking in that this just now.
1:52:47
Oh, I haven't got this function in my script doing not.
1:52:56
Oh, no. I've lost my function that I'll have to come back to this thing and I'm almost tempted to run.
1:53:01
No, I haven't got time. So in this case, given this thing like six divided by the answer, it was infinity, because the first argument is positive,
1:53:13
because the first argument is not is not negative, and therefore I have to pick the second as a result of the function.
1:53:21
But what would happen if the first dog were negative to the first time he's negative, this clause is true and the answer is zero.
1:53:28
And the second argument, the why in this case, he's never needed.
1:53:38
So we never hit the need to divide six by zero that we don't get to infinity and out pops the zero.
1:53:43
So can you see what's called lazy evaluation?
1:53:49
What it means is don't do anything as you have to, because it could be that there are some arguments presented.
1:53:51
The functions float around, which ultimately you never need. And you might also think ahead, he said, well, this wasn't just being divided by zero,
1:53:58
so this particular criticism, but this might be some massive computation, you know,
1:54:06
like calculus, know, computing,
1:54:11
all the letter A's in the Yellow Pages of the telephone directory for the North America or something is going to take a long time to do.
1:54:13
But but if you never need it, why do it?
1:54:20
Delays evaluation for free gives you a mechanism for shortcutting computations that ultimately are never needed.
1:54:23
So much more of this later. I'm not going to stop because you have two minutes before and you need a break.
1:54:31
Very quick question, Xinyang.
1:54:36
If you then I'm going to stop as so it's something like when your car function, you actually like past something like an.
1:54:39
Oh, I think we've lost you, never mind, you can ask the question next time I'm going to stop so you can have a little bit of a break.
1:54:52
I'll catch you on, I think, on Monday. I'll see you in the labs tomorrow.
1:54:58
So cheerio. Bye bye. Excuse me, sir.
1:55:02